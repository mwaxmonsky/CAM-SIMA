{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CAM-SIMA developer documentation","text":""},{"location":"conversion/ccpp-conversion-guide/","title":"CAM Parameterization to CCPP","text":""},{"location":"conversion/ccpp-conversion-guide/#background","title":"Background","text":""},{"location":"conversion/ccpp-conversion-guide/#running-jobs-in-cam-and-cam-sima-primer-experienced-users-can-jump-to-the-next-section","title":"Running jobs in CAM and CAM-SIMA primer (experienced users can jump to the next section)","text":"<p>To make runs in either CAM or CAM-SIMA the commands are identical:</p> <pre><code>./create_newcase\u2026 #(the commands will differ and are specified later in this document)\ncd YourCaseDirectory\n./xmlchange\u2026 #(specific commands are specified later in this document)\n./case.setup\n./case.build\n./case.submit\n</code></pre> <p>Depending on which machine you are on, you may prefer to run the ./case.build command on a compute node instead of the login node due to user resource utilization limits on the login nodes.</p> <p>For more detailed information on case creation and building, see https://ncar.github.io/CAM/doc/build/html/users_guide/building-and-running-cam.html</p>"},{"location":"conversion/ccpp-conversion-guide/#prep-work","title":"Prep Work","text":""},{"location":"conversion/ccpp-conversion-guide/#conversion-spreadsheet","title":"Conversion Spreadsheet","text":"<p>Put the parameterization that you are going to convert into the conversion spreadsheet https://docs.google.com/spreadsheets/d/1_1TTpnejam5jfrDqAORCCZtfkNhMRcu7cul37YTr_WM/edit#gid=0</p>"},{"location":"conversion/ccpp-conversion-guide/#create-github-issues","title":"Create Github Issues","text":"<p>Create a Github Issue in the ESCOMP/CAM repo that states which physics parameterization you are planning to convert to the CCPP framework.  Then create another issue in the ESCOMP atmospheric physics repo describing the same physics parameterization that you are now planning to add to the collection of NCAR CCPP physics suites.  Doing this allows the software engineers to keep track of which physics routines are being worked on, and which still need to be assigned.  The goal of converting the physics parameterization is to ultimately have the CCPP-ized physics package reside in ESCOMP atmospheric physics and be removed from ESCOMP/CAM.</p>"},{"location":"conversion/ccpp-conversion-guide/#setting-up-your-sandbox","title":"Setting up your sandbox","text":"<p>Make sure you have github forks for both ESCOMP/CAM-SIMA and ESCOMP/atmospheric_physics.  If needed see https://github.com/ESCOMP/Cam/wiki/CAM-Development-Workflow-in-GitHub#how-to-makestore-revisions-to-your-personal-cam-repository-github-fork</p> <p>To begin, fork ESCOMP/CAM-SIMA: </p> <p>And select the <code>Create new fork</code> option.  This will bring you to the \"Create new fork\" screen: </p> <p>Uncheck the \"Copy the <code>main</code> branch only\" option</p> <p>Failure to uncheck this will prevent you from pulling in updates from the <code>development</code> branch easily.</p> <p>As you make changes and want to commit them to your github repos, you will be managing two separate repos.  When you issue git commands, be aware of where you are in your code tree.  If you want to see changes in CAM-SIMA, you can issue a <code>git status</code> in the main CAM-SIMA directory.  If you want to see changes in the atmospheric_physics repo, make sure you are in <code>src/physics/ncar_ccpp</code> before you issue the <code>git status</code> command.  All other git commands will be relative to your current working directory as well.</p>"},{"location":"conversion/ccpp-conversion-guide/#opttional-pre-split-tthe-module","title":"Opttional: pre-split tthe module","text":"<p>Many CAM schemes have more than one <code>run</code> function contained within them.  To seperate them into seperate files and test them:  - In the copied atmospheric physics directory, create a seperate submodule for each parameterization which has <code>run</code> method.    - An easy way to see what routines need to be seperated out is to look at the <code>use</code> statement(s) for your parameterization.  If more than one routine is listed, you most likely will need to seperate these out. - If there is shared module level data or shared subroutines which are called internally, put these all in a <code>&lt;schemename&gt;_common.F90</code> module.</p>"},{"location":"conversion/ccpp-conversion-guide/#ccpp-ization","title":"CCPP-ization","text":""},{"location":"conversion/ccpp-conversion-guide/#convert-the-code-in-the-portable-parameterization-layer","title":"Convert the code in the \"portable\" parameterization layer","text":"<p>SCHEMES = the base level routines which are currently called bby the CAM interface routines.</p> <ol> <li>Convert the original routines in the file you copied over to <code>src/physics/ncar_ccpp/&lt;schemename&gt;/&lt;module_name&gt;.F90</code> to one or more of the 5 following subroutines.  These will be called by CCPP in CAM-SIMA and in CAM6.</li> </ol> <p><code>&lt;module_name&gt;</code> should be the full name of your module</p> <p>For example, if you are converting the <code>tj2016</code> <code>precip_tend</code> function, then <code>&lt;module_name&gt;</code> would be <code>tj2016_precip_tend</code>.</p> <p>Parameterizations may not need all of the routines listed below and do not need to supply them if they are not needed.  However, all subroutine input/output arguments need to have an <code>intent</code> label (you may refer to <code>src/atmos_phys/kessler</code> and <code>src/atmos_phys/held_suarez</code> for specific examples).</p> <ul> <li><code>&lt;module_name&gt;_init</code></li> <li> <p>Add all code that is run only during the first time step (<code>nstep=0</code>).  Typically fold <code>register</code> and <code>init</code> routines in current CAM into this routine.</p> </li> <li> <p><code>&lt;module_name&gt;_timestep_init</code></p> </li> <li> <p>Add all pre-processing code needed by the scheme at the start of each timestep.  This may contain code from the CAM interface routine which prepares data for the run routine at each timestep.</p> </li> <li> <p><code>&lt;module_name&gt;_run</code></p> </li> <li> <p>This is the workhorse routine which is run at each timestep.  The bulk of your ported code will likely be here.</p> </li> <li> <p><code>&lt;module_name&gt;_timestep_final</code></p> </li> <li> <p>Add all post-processing code needed by the scheme at the end of each timestep.  This may contain code from the CAM interface routine which manipulates data after the run routine at each timestep.</p> </li> <li> <p><code>&lt;module_name&gt;_final</code></p> </li> <li>Most current CAM routines do not have code in this category.  This code is run once at the very end of the job.</li> </ul>"},{"location":"design/cam-build-process/","title":"Build process","text":"<p>In order to describe the build process, we need to define several source and build directories:</p> <ul> <li><code>&lt;srcroot&gt;</code> : The CAM-SIMA sandbox being built. From a case directory, this can be found with <code>./xmlquery SRCROOT.</code></li> <li><code>&lt;caseroot&gt;</code>: The location of the case being built.</li> <li><code>&lt;src_mods&gt;</code>: The location of the CAM-SIMA source mods, located at <code>&lt;caseroot&gt;/SourceMods/src.cam.</code></li> <li><code>&lt;bldroot&gt;</code> : The location of CAM-SIMA generated code and compiled code (<code>.o</code> and <code>.mod</code>). See <code>atm/obj</code> under <code>./xmlquery OBJROOT</code>.</li> </ul>"},{"location":"design/cam-build-process/#build-sequence","title":"Build Sequence","text":"<p>Given the context above, the following is the CAM-SIMA build sequence:</p> <ol> <li>Create a <code>ConfigCAM</code> object, used to store build configuration information. Code can be found in <code>&lt;srcroot&gt;/cime_config/cam_config.py</code><ul> <li>Inputs:<ul> <li><code>&lt;case&gt;</code>: A CIME case object</li> <li><code>&lt;case_log&gt;</code>: A python logger, which is usually created by CIME itself</li> </ul> </li> <li>Outputs:<ul> <li><code>config_dict</code>: A dictionary of configure options, with the dictionary keys being the name of the config variable/option, and the dictionary values being special config variable objects that contain the following properties:<ul> <li><code>name</code>: The name of the config option/variable. This is what is used as the key in the <code>config_dict</code> dictionary</li> <li><code>desc</code>: A text description of what this particular config option is, and what sort of values the config option should have.</li> <li><code>value</code>: The value of that config option/variable. Currently can only be an integer, string, or list of integers or strings.</li> <li><code>valid_vals</code>: Optional property that contains either a list or range of valid values for this particular config entry</li> <li><code>valid_type</code>: Optional property for a list-type config option that states what data type the list elements can have.</li> <li><code>is_nml_attr</code>: Logical that states whether this config option can be used as an XML attribute in a namelist definition file.</li> </ul> </li> </ul> </li> <li>Additional info:<ul> <li>The <code>ConfigCAM</code> object also has various build-in methods that are used to call other steps in the build workflow, change the value of a given config variable, or print extra config info to the provided python logger.</li> <li>The <code>ConfigCAM</code> object currently has no uses outside <code>buildnml</code> and <code>buildlib</code>, and so is not saved after those steps are complete.</li> </ul> </li> </ul> </li> <li>Generate CAM-SIMA source code. This sequence has several steps, each of which is performed if any of its inputs has changed.<ul> <li>Create or read in a <code>BuildCacheCAM</code> object (<code>&lt;srcroot&gt;/cime_config/cam_build_cache.py</code>).<ul> <li><code>&lt;build_cache&gt;</code>: An optional cache file (created by previous build). This file is created in the case build directory (bld/atm/obj).</li> </ul> </li> <li>Create the physics derived data types using the registry (if required).</li> <li>Find all scheme metadata files for configured suites.</li> <li>Find any active schemes with namelist XML variables<ul> <li>Create metadata file with namelist variables</li> <li>Create namelist-reading module (to go with metadata file).</li> </ul> </li> <li>Call the CCPP Framework to generate glue code (CAPS), (if required).</li> </ul> </li> </ol>"},{"location":"design/cam-build-process/#cam-sima-source-and-namelist-generation-buildnml-workflow","title":"CAM-SIMA source and namelist generation (buildnml) workflow","text":"<p>The diagram above displays everything that occurs when CAM-SIMA's <code>buildnml</code> is called by CIME, which occurs after the user calls <code>preview_namelists</code>, <code>case.build</code>, or <code>case.submit</code>.</p> <p>All blue boxes represent source code, and are listed as \"source file: function/object used\", and all objects or functions that have a \"+\" are automatically tested whenever a Pull Request is opened, updated, or merged.</p> <p>All orange boxes are input files that are used by the code, while all green boxes are output files that are generated. It is important to note that additional files are generated as well, specifically a build cache and a CCPP datatable, but those files are used internally in the build scripts shown here and not by the final model executable, and thus aren't listed here.</p> <p>Finally, the arrows show the order of operations, starting with <code>buildnml</code>, with the top two source code boxes representing python classes that are used by the functions/objects directly below them.</p>"},{"location":"design/cam-run-process/","title":"Run process","text":"CAM-SIMA run sequence* <p>*Static images can be found at the bottom of this page</p>"},{"location":"design/cam-run-process/#cam-sima-api","title":"CAM-SIMA API","text":"<p>Upon running <code>./case.submit</code> the core CAM-SIMA driver code* is in <code>$CAM-SIMA/src/control/cam_comp.F90</code>. This section lays out each of the subroutines within <code>cam_comp.F90</code>. The subroutines in <code>cam_comp.F90</code> are set up to mirror the phases of the Common Community Physics Package (CCPP).</p> <p>* <code>cam_comp.F90</code> subroutines are called by the NUOPC cap: <code>$CAM-SIMA/src/cpl/nuopc/atm_comp_nuopc.F90</code></p>"},{"location":"design/cam-run-process/#cam_init","title":"cam_init","text":"<p><code>cam_init</code> sets up the metadata and configuration objects/modules for the run. It is called once at startup. Below are the variables passed in:</p> Variable (intent) Definition How it's Used caseid (in) case name (as input to ./create_newcase) metadata for cam_control_mod and cam_history ctitle (in) case title (matches caseid) metadata for cam_control_mod and cam_history model_doi_url (in) CESM model DOI (currently hard-coded to \"non_set\") metadata for cam_history initial_run_in (in) logical that is TRUE if this is a startup run** determines whether to call dyn_init or read restart restart_run_in (in) logical that is TRUE if this is a restart run** metadata for cam_control_mod branch_run_in (in) logical that is TRUE if this is a branch run** metadata for cam_control_mod post_assim_in (in) logical that is TRUE if data assimilation mode (DART) is on metadata for cam_control_mod calendar (in) calendar type (NOLEAP or GREGORIAN) input to time manager init brnch_retain_casename (in) flag to allow a branch to use the same caseid as the run being branched from metadata for cam_control_mod aqua_planet (in) flag to run model in aqua planet mode metadata for cam_control_mod single_column (in) flag to run the single column model (SCAM) passed into scam_readnl (not yet enabled in CAM-SIMA scmlat (in) SCAM latitude passed into scam_readnl (not yet enabled in CAM-SIMA) scmlon (in) SCAM longitude passed into scam_readnl (not yet enabled in CAM-SIMA) eccen (in) Earth's eccentricity factor used to set module-level <code>eccen</code> in cam_control_mod obliqr (in) Earth's obliquity in radians used to set module-level <code>obliqr</code> in cam_control_mod lambm0 (in) Mean longitude of perihelion at the vernal equinox (radians) used to set module-level <code>lambm0</code> in cam_control_mod mvelpp (in) Earth's moving vernal equinox longitude of perihelion plus pi (radians) used to set module-level <code>mvelpp</code> in cam_control_mod perpetual_run (in) flag to determine if perpetual mode is enabled passed to time manager init perpetual_ymd (in) perpetual year, month, day (YYYYMMDD) used to determine the sun position and interpolate boundary data sets passed to time manager init dtime (in) model timestep size in seconds passed to time manager init start_ymd (in) start date (YYYYMMDD) passed to time manager init start_tod (in) start time of day (sec) passed to time manager init ref_ymd (in) reference date (YYYYMMDD) (defaults to start_ymd) passed to time manager init ref_tod (in) reference time of day (sec) (defaults to start_tod) passed to time manager init stop_ymd (in) stop date (YYYYMMDD) passed to time manager init stop_tod (in) stop time of day (sec) passed to time manager init curr_ymd (in) current date (YYYYMMDD) (same as start date) passed to time manager init curr_tod (in) current time of day (sec) (same as start tod) passed to time manager init cam_in (inout) surface exchange object - coupler to CAM-SIMA allocated if this is an initial run cam_out (inout) surface exchange object - CAM-SIMA to coupler allocated if this is an initial run <p>** For additional information on run types, see the CESM Tutorial</p> <p><code>cam_init</code> calls the following key subroutines (locations) in this order:</p> <ol> <li><code>cam_ctrl_init</code> (<code>src/control/cam_control_mod.F90</code>): Sets the module-level run configuration variables; logs configurations to the atm log</li> <li><code>cam_ctrl_set_orbit</code> (<code>src/control/cam_control_mod.F90</code>): Sets the module-level orbital variables</li> <li><code>timemgr_init (</code>src/utils/time_manager.F90`): Initializes the time manager; logs configurations to the atm log</li> <li><code>read_namelist</code> (<code>src/control/runtime_opts.F90</code>): Reads all namelists for the run, including auto-generated scheme namelists (see build process)</li> <li><code>cam_ctrl_set_physics_type</code> (<code>src/control/cam_control_mod.F90</code>): sets module-level configuration for variables for simple physics and moist physics schemes; logs configurations to atm log</li> <li><code>cam_initfiles_open</code> (<code>src/control/cam_initfiles.F90</code>): Opens initial or restart file, and topography file if specified</li> <li><code>cam_register_constituents</code> (<code>src/control/cam_comp.F90</code>): Sets the total number and advected number of constituents; currently ALWAYS adds water vapor as constituent (expected by the SE dycore)</li> <li><code>air_composition_init</code> (<code>src/data/air_composition.F90</code>): Initializes air-composition-dependent model constants</li> <li><code>model_grid_init</code> (<code>src/dynamics/&lt;dycore&gt;/dyn_grid.F90</code>): Initializes model grids and decompositions</li> <li><code>cam_ccpp_initialize_constituents</code> (<code>$CASE/bld/atm/obj/ccpp/cam_ccpp_cap.F90</code>): initializes the constituent data array; after this point, we cannot add new constituents</li> <li><code>dyn_init</code> (<code>src/dynamics/&lt;dycore&gt;/dyn_comp.F90</code>): Initializes the dynamical core</li> <li><code>atm2hub_alloc</code> and <code>hub2atm_alloc</code> (<code>src/control/camsrfexch.F90</code>): Allocates and sets up surface exchange data</li> <li><code>phys_init</code> (<code>src/physics/utils/phys_comp.F90</code>): Initializes physics (includes call to CCPP cap to run init phases of schemes in the Suite Definition File (SDF)</li> <li><code>stepon_init</code> (<code>src/dynamics/&lt;dycore&gt;/stepon.F90</code>): Initializes dynamics &lt;--&gt; physics coupling</li> </ol>"},{"location":"design/cam-run-process/#cam_timestep_init","title":"cam_timestep_init","text":"<p><code>cam_timestep_init</code> is called at the start of each timestep. It has no input/output/inout variables.</p> <p>The routine calls the following subroutines (locations) in this order:</p> <ol> <li><code>stepon_timestep_init</code> (<code>src/dynamics/&lt;dycore&gt;/stepon.F90</code>): First phase of dynamics (couple from dynamics to physics); also returns timestep for physics</li> <li><code>phys_timestep_init</code> (<code>src/physics/utils/phys_comp.F90</code>):<ol> <li>Read un-initialized data from initial data file<ul> <li>For the null dycore, this means we're reading most physics input variables (as defined in <code>src/data/registry.xml</code>) from the ncdata file</li> <li>For the SE dycore, we are reading in any variables not marked as initialized by the SE dycore initialization</li> </ul> </li> <li>Calls the CCPP cap to run timestep_init phases of all schemes in the user-specified SDF</li> </ol> </li> </ol>"},{"location":"design/cam-run-process/#cam_run1","title":"cam_run1","text":"<p><code>cam_run1</code> is the first \"run\" phase called in the physics loop. It is called every timestep BEFORE the mediator/surface coupler and calls the following subroutine (location):</p> <ol> <li><code>phys_run1</code> (<code>src/physics/utils/phys_comp.F90</code>): Calls the run phase for all physics schemes in the \"physics_before_coupler\" group in the SDF</li> </ol>"},{"location":"design/cam-run-process/#cam_run2","title":"cam_run2","text":"<p><code>cam_run2</code> is the second \"run\" phase called in the physics loop. It is called every timestep AFTER the mediator/coupler. Input/output variables:</p> Variable (intent) Definition How it's Used cam_in (inout) surface exchange object - input to CAM-SIMA Passed into stepon_run2 cam_out (inout) surface exchange object - output from CAM-SIMA Passed into stepon_run2 <p><code>cam_run2</code> calls these subroutines (locations):</p> <ol> <li><code>phys_run2</code> (<code>src/physics/utils/phys_comp.F90</code>): Calls the run phase for all physics schemes in the \"physics_after_coupler\" group in the SDF</li> <li><code>stepon_run2</code> (<code>src/dynamics/&lt;dycore&gt;/stepon.F90</code>): The second phase of dynamics (couple from physics to dynamics)</li> </ol>"},{"location":"design/cam-run-process/#cam_run3","title":"cam_run3","text":"<p><code>cam_run3</code> is the third \"run\" phase called in the physics loop. It is called every timestep AFTER cam_run3 and BEFORE cam_run4 (unsurprisingly). In/out variables:</p> Variable (intent) Definition How it's Used cam_out (inout) surface exchange object - output from CAM-SIMA Passed into stepon_run3 <p><code>cam_run3</code> calls the following subroutine (location):</p> <ol> <li><code>stepon_run3</code> (<code>src/dynamics/&lt;dycore&gt;/stepon.F90</code>): Calls <code>dyn_run</code>, which runs the dycore</li> </ol>"},{"location":"design/cam-run-process/#cam_run4","title":"cam_run4","text":"<p><code>cam_run4</code> currently does nothing! (but it is called every timestep)</p>"},{"location":"design/cam-run-process/#cam_timestep_final","title":"cam_timestep_final","text":"<p><code>cam_timestep_final</code> runs at the end of each timestep. In/out variables:</p> Variable (intent) Definition How it's Used rstwr (in) flag to write a restart file Passed into history_wrap_up nlend (in) flag to indicate whether this is the final timestep Passed into history_wrap_up <p><code>cam_timestep_final</code> calls the following subroutines (locations):</p> <ol> <li>History routines. If it's not the last (half) timestep,<ol> <li><code>history_write_files</code> (<code>src/history/cam_history.F90</code>): Writes fields to user-configured history files (if applicable)</li> <li><code>history_wrap_up</code> (<code>src/history/cam_history.F90</code>): Closes files and zeros buffers as necessary</li> </ol> </li> <li><code>phys_timestep_final</code> (<code>src/physics/utils/phys_comp.F90</code>):<ol> <li>Calls the timestep_final phase for all physics schemes in the SDF</li> <li>If <code>ncdata_check</code> is set in <code>user_nl_cam</code>, calls <code>physics_check_data</code> (<code>$CASE/bld/atm/obj/phys_init/physics_inputs.F90</code>) to perform snapshot checking</li> </ol> </li> </ol>"},{"location":"design/cam-run-process/#cam_final","title":"cam_final","text":"<p><code>cam_final</code> is called once at the end of the model execution. In/out variables:</p> Variable (intent) Definition How it's Used cam_in (inout) surface exchange object - input to CAM-SIMA Deallocated cam_out (inout) surface exchange object - output from CAM-SIMA Deallocated <p><code>cam_final</code> calls the following subroutines (locations):</p> <ol> <li><code>phys_final</code> (<code>src/physics/utils/phys_comp.F90</code>): calls \"final\" phase of all schemes in the SDF</li> <li><code>stepon_final</code> (<code>src/dynamics/&lt;dycore&gt;/stepon.F90</code>): finalizes dycore (doesn't currently do anything)</li> <li><code>atm2hub_deallocate</code> and <code>hub2atm_deallocate</code> (<code>src/control/camsrfexch.F90</code>): deallocate cam_in/cam_out objects</li> </ol>"},{"location":"design/cam-run-process/#static-run-sequence-images","title":"Static run sequence images","text":""},{"location":"design/ccpp-in-cam-sima/","title":"CCPP in CAM-SIMA","text":""},{"location":"design/ccpp-in-cam-sima/#overview","title":"Overview","text":"<p>The core Common Community Physics Package (CCPP) documentation can be found here. This section details the code structure and implementation of the CCPP Framework within CAM-SIMA. That said here's a quick overview of the CCPP:</p> <ul> <li>A CCPP-enabled model consists of the following components (depicted in the diagram below):<ul> <li>Host model and dynamical core</li> <li>CCPP-compliant physics schemes (organized into Suite Definition Files [SDFs])</li> <li>Caps generated by the CCPP framework to connect the host model to the physics schemes</li> </ul> </li> </ul> <p></p> <p>CCPP-compliant physics schemes must adhere to the following criteria:</p> <ul> <li>Must be broken up into only the following phases:<ul> <li>register (anything in the scheme that must be done before the grid is initialized) - run once at startup</li> <li>init - run once at startup</li> <li>timestep_init - run at beginning of every physics timestep</li> <li>run - run on every timestep</li> <li>timestep_final - run at the end of every timestep</li> <li>final - run once at the end of model execution</li> </ul> </li> <li>Must contain metadata for all input/output/inout variables passed into each phase (see metadata example below)</li> <li>Must not have use statements outside of the following allowed CCPP use statements (with the exception of <code>dependencies</code>, but we're not getting into that now):<ul> <li>ccpp_kinds</li> <li>ccpp_constituent_prop_mod</li> </ul> </li> </ul> <p>Metadata example (snippet taken from <code>kessler.meta</code>)</p> <pre><code>[ precl ]\n  standard_name = total_precipitation_rate_at_surface\n  long_name = Total precipitation rate at surface\n  units = m s-1\n  dimensions = (horizontal_loop_extent)\n  type = real | kind = kind_phys\n  intent = out\n[ relhum ]\n  standard_name = relative_humidity\n  long_name = Relative humidity\n  units = percent\n  dimensions = (horizontal_loop_extent, vertical_layer_dimension)\n  type = real | kind = kind_phys\n  intent = out\n[ scheme_name ]\n  standard_name = scheme_name\n  units = none\n  type = character | kind = len=64\n  dimensions = ()\n  intent = out\n\n</code></pre> <p>CCPP-compliant physics schemes are organized into suite definition files (SDFs). An SDF tells the framework which schemes will be run in what order. Separating schemes into \"groups\" also allows the run phases of those groups to be called separately by the host model. Here's an example SDF (from suite_kessler.xml):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;suite name=\"kessler\" version=\"1.0\"&gt;\n  &lt;group name=\"physics_before_coupler\"&gt;\n    &lt;scheme&gt;calc_exner&lt;/scheme&gt;\n    &lt;scheme&gt;temp_to_potential_temp&lt;/scheme&gt;\n    &lt;scheme&gt;calc_dry_air_ideal_gas_density&lt;/scheme&gt;\n    &lt;scheme&gt;wet_to_dry_water_vapor&lt;/scheme&gt;\n    &lt;scheme&gt;wet_to_dry_cloud_liquid_water&lt;/scheme&gt;\n    &lt;scheme&gt;wet_to_dry_rain&lt;/scheme&gt;\n    &lt;scheme&gt;kessler&lt;/scheme&gt;\n    &lt;scheme&gt;potential_temp_to_temp&lt;/scheme&gt;\n    &lt;scheme&gt;dry_to_wet_water_vapor&lt;/scheme&gt;\n    &lt;scheme&gt;dry_to_wet_cloud_liquid_water&lt;/scheme&gt;\n    &lt;scheme&gt;dry_to_wet_rain&lt;/scheme&gt;\n    &lt;scheme&gt;kessler_update&lt;/scheme&gt;\n    &lt;scheme&gt;qneg&lt;/scheme&gt;\n    &lt;scheme&gt;geopotential_temp&lt;/scheme&gt;\n    &lt;scheme&gt;cam_state_diagnostics&lt;/scheme&gt;\n    &lt;scheme&gt;kessler_diagnostics&lt;/scheme&gt;\n  &lt;/group&gt;\n  &lt;group name=\"physics_after_coupler\"&gt;\n    &lt;scheme&gt;cam_tend_diagnostics&lt;/scheme&gt;\n  &lt;/group&gt;\n&lt;/suite&gt;\n</code></pre> <p>The framework code is primarily python code that generates Fortran caps. The class structure looks like:</p> <p>Given CCPP-compliant physics schemes and one or more SDF, the framework generates caps for the host model to call at the appropriate time. The core files generated by the framework are:</p> <ul> <li><code>&lt;host&gt;_ccpp_cap.F90</code>: contains the interface layer between the host and the suite(s)</li> <li><code>ccpp_&lt;suite&gt;_cap.F90</code>: contains one subroutine per phase (including one run phase per group) in which the phases of the schemes within the suite are called in order<ul> <li>There is one suite cap generated for each suite being run</li> </ul> </li> <li><code>ccpp_datatable.xml</code>: consolidates metadata into an XML file to be used as desired by the host model</li> </ul>"},{"location":"design/ccpp-in-cam-sima/#code-structure","title":"Code Structure","text":"<p>How CAM-SIMA and the CCPP come together: </p>"},{"location":"design/ccpp-in-cam-sima/#host-model","title":"Host Model","text":"<p>The core host model code is what is held in the CAM-SIMA github repository, plus code that is generated at build-time (or preview_namelists-time) based on the registry (<code>src/data/registry.xml</code>).</p>"},{"location":"design/ccpp-in-cam-sima/#physics","title":"Physics","text":"<p>The CCPP physics scheme code exists in the atmospheric_physics repository, which exists as a submodule of CAM-SIMA in the following location: <code>$CAM-SIMA/src/physics/ncar_ccpp</code></p> <p>SDFs are located in the root directory of the repository and scheme source code is in the relevant subdirectories. </p> <p>The <code>diagnostics</code> directory contains all diagnostic schemes (the global ones used for state and tendency output, as well as the scheme-specific diagnostic schemes).</p> <p>The <code>to_be_ccppized</code> directory contains physics schemes and utilties that have not been CCPP-ized, but were needed by an CCPP-ized scheme.</p> <p>The <code>utilities</code> directory contains schemes that are used regularly, such as tendency applicators and state converters. See below for more.</p>"},{"location":"design/ccpp-in-cam-sima/#generated-caps","title":"Generated caps","text":"<p>The caps generated by the CCPP Framework at model build time (or preview_namelists-time) can be found in the following location: <code>$CASE/bld/atm/obj/ccpp/</code></p>"},{"location":"design/ccpp-in-cam-sima/#implementation","title":"Implementation","text":"<p>All CCPP phases are called from the physics driver (<code>src/physics/utils/phys_comp.F90</code>). You can see the order of these calls more thoroughly in the documented run sequence.</p>"},{"location":"design/ccpp-in-cam-sima/#host-side-variables-and-metadata","title":"Host-side variables and metadata","text":"<p>For a CCPP-ized physics scheme to work, the framework needs to be able to find a matching variable on the host side for each input variable for the suite(s) in question. This means that CAM-SIMA needs to allocate, initialize, and provide metadata for these variables. We do this in two ways:</p> <ul> <li>Adding metadata to existing CAM modules (such as <code>src/data/physconst.F90</code>) so that a scheme can access an existing host model variable<ul> <li>All static host-side metadata schemes are included at the top of the registry</li> </ul> </li> <li>Adding a variable to the registry (<code>src/data/registry.xml</code>)<ul> <li>You can learn more about how the registry is used to generate a Fortran module and corresponding metadata here</li> </ul> </li> </ul> <p>The registry-based code generator is run before the CCPP framework does its magic, so, when it's time, the framework can connect the dots between the host model and the physics.</p>"},{"location":"design/ccpp-in-cam-sima/#state-and-tendency-variables","title":"State and tendency variables","text":"<p>Two of the most commonly used and referred-to objects in CAM-SIMA are:</p> <ul> <li>physics_state</li> <li>physics_tend</li> </ul> <p>The Fortran for both objects is auto-generated by CAM-SIMA based on the registry (<code>$CAM-SIMA/src/data/registry.xml</code>). The generated code can be found here: <code>$CASE/bld/atm/obj/cam_registry/physics_types.F90</code>. The objects are used by the host model (CAM-SIMA), while the CCPP physics take the individual component variables as inputs.</p>"},{"location":"design/ccpp-in-cam-sima/#physics-state","title":"Physics state","text":"<p>The physics_state object in CAM-SIMA contains the current values for a select set of variables that describe the atmosphere, at the resolution specified by the input grid.</p> <p>Some examples of these core \"state\" variables include temperature (<code>T</code>), eastward wind (<code>U</code>), and northward wind (<code>V</code>)</p> <p>As a rule, CAM-SIMA physics schemes do not update the state directly and instead return tendencies (see below) which are then applied to the state later in the run phase. This is called time splitting, which means that all physics since the last state update get the same input state. The alternative, process splitting, means that the output state of one scheme serves as the input state of the next.</p> <p>NOTE: Although constituents are handled independently of the <code>physics_state</code> object (they are handled by the CCPP framework), they ARE considered state variables.</p>"},{"location":"design/ccpp-in-cam-sima/#physics-tendencies","title":"Physics tendencies","text":"<p>The physics tendencies represent how a given scheme (or schemes) changes the state in a single model timestep. The tendencies are accumulated until it is time to apply them to the state. There is one tendency for each state variable being \"updated\" by the scheme. Some of these tendency variables are held within the physics_tend object, but others are internal to the physics.</p> <p>The module <code>$CAM-SIMA/src/physics/ncar_ccpp/utilities/physics_tendency_updaters.F90</code> includes the schemes to apply the tendencies to the relevant state variables. These schemes are added to the SDF whenever the state should be updated. Each calculation looks like: <code>state_var = state_var + tend*dt</code> where <code>dt</code> is the timestep size.</p>"},{"location":"design/constituents/","title":"Constituents","text":""},{"location":"design/constituents/#introductionoverview","title":"Introduction/Overview","text":"<p>Some definitions to start (as written by a non-scientist, so there is more nuance than this!):</p> <ul> <li>A constituent is a physical quantity or substance that exists in the atmosphere</li> <li>A constituent can be advected, which means it is moved through the atmosphere by some sort of dynamical method<ul> <li>The dynamical core (dycore) is the part of an atmosphere model (like CAM-SIMA) that advects the quantities over the underlying grid. Dynamical cores include:<ul> <li>null/none - the null dycore does nothing and is used in CAM-SIMA to validate physics schemes</li> <li>spectral element (SE): the only dycore currently implemented in CAM-SIMA</li> <li>finite-volume cubed-sphere (FV3): not currently implemented in CAM-SIMA</li> <li>model for prediction across scales (MPAS): in progress</li> </ul> </li> </ul> </li> <li>A constituent had additional properties, such as:<ul> <li>water type: can be \"dry\", \"wet\", or \"moist\" (we can convert between any of these quantities - \"dry\" means that it's the \"amount\" of that constituent with respect to dry air</li> <li>mixing ratio type: can be \"volume\" or \"mass\"<ul> <li>volume mixing ratio: constituent values are a ratio of how much of the constituent exists per mole of air (units = mol mol-1)</li> <li>mass mixing ratio: constituent values are the mass of the constituent per unit volume (kg m-3)</li> </ul> </li> <li>molar mass: Molar mass of a given quantity; used in converting between mass mixing ratio and volume mixing ratio</li> <li>thermodynamically active: thermodynamically active constituents in CAM-SIMA can be found in <code>src/data/air_composition.F90</code></li> <li>minimum value: The scheme <code>qneg</code> will set constituent values that are less than the minimum to the minimum</li> </ul> </li> </ul>"},{"location":"design/constituents/#cam-sima-constituent-handling","title":"CAM-SIMA constituent handling","text":""},{"location":"design/constituents/#determining-constituents","title":"Determining constituents","text":"<p>There are three ways to identify a quantity as a constituent in CAM-SIMA:</p> <ol> <li>Constituent is provided by host (CAM-SIMA):<ul> <li>Host model constituents allow for constituents to be added as a constituent independent of the physics being run</li> <li>Host constituents are added in <code>cam_register_constituents</code> (in <code>src/control/cam_comp.F90</code>). Currently, we are always adding water vapor as a host constituent because it is expected by the SE dycore.</li> </ul> </li> <li>Constituent is a build-time physics constituent in a CCPP-ized scheme:<ul> <li>If a quantity is known to be a constituent at build-time, it is identified in the metadata for the scheme with: <code>advected = True</code></li> </ul> </li> <li>Constituent is a run-time physics constituent in a CCPP-ized scheme:<ul> <li>Sometimes, a scheme does not know what constituents it will require until run-time. In this case, an array of constituent properties (one for each needed constituent) is returned from the cam register phase. An example of how this works can be found in <code>src/physics/ncar_ccpp/musica/micm/micm.F90</code></li> </ul> </li> </ol>"},{"location":"design/constituents/#registering-initializing-constituents","title":"Registering &amp; Initializing Constituents","text":"<p>The registration and initializaiton of the constituent data array and the constituent properties object are done through calls to the generated CCPP cap.</p> <ul> <li>cam_ccpp_register_constituents: combines the three sources of constituents into one <code>ccpp_model_constituents_t</code> object<ul> <li>Called before the physics grid (which requires the number of constituents) is initialized</li> </ul> </li> <li>cam_ccpp_initialize_constituents: initializes the data array within the <code>ccpp_model_constituents_t</code> object<ul> <li>Called after the physics grid is initialized (so we know the size of the array allocate)</li> <li>The array is initialized to (columns, levels, number of constituents)</li> </ul> </li> </ul>"},{"location":"design/constituents/#constituent-usage","title":"Constituent Usage","text":"<p>Constituent values and properties can be accessed from the host side and from the physics in the following ways:</p> <ul> <li>Host side: constituents and properties can be accessed via the host model and dycore by way of the <code>cam_constituents.F90</code> module, which is an interface to the CCPP cap, which is in turn an interface to the constituents object</li> <li>Physics: the constituent array and/or the constituent properties object are passed into a scheme via the following metadata (local name and intent may vary):</li> </ul> <pre><code>[ q ]\n  standard_name = ccpp_constituents\n  units = none\n  type = real | kind = kind_phys\n  dimensions = (horizontal_loop_extent,vertical_layer_dimension,number_of_ccpp_constituents)\n  intent = inout\n[ const_props ]\n  standard_name = ccpp_constituent_properties\n  units = None\n  type = ccpp_constituent_prop_ptr_t\n  dimensions = (number_of_ccpp_constituents)\n  intent = in\n</code></pre>"},{"location":"design/constituents/#ccpp-framework-constituent-handling","title":"CCPP Framework constituent handling","text":"<p>This section can be removed when constituents are documented in the CCPP Framework documentation.</p>"},{"location":"design/constituents/#constituent-object-fortran","title":"Constituent object (Fortran)","text":"<p>The constituent object (found in <code>$CAM-SIMA/ccpp_framework/src/ccpp_constituent_prop_ mod.F90</code>) is a flexible and extendable means of containing necessary constituent data for the framework. The primary object is <code>ccpp_model_constituents_t</code>.</p> <p></p> <p>This object, importantly, contains the following properties (for which there is metadata; CCPP standard name in parenthesis):</p> <ul> <li><code>const_metadata</code> (ccpp_constituent_properties)</li> <li><code>num_layer_vars</code> (number_of_ccpp_constituents)</li> <li><code>num_advected_vars</code> (number_of_ccpp_advected_constituents)</li> <li><code>vars_layer</code> (ccpp_constituents)</li> </ul> <p>The <code>const_metadata</code> property is of type <code>ccpp_constituent_prop_ptr_t</code>, which contains a pointer to a <code>ccpp_constituent_properties_t</code> object, as depicted above. This object contains all of the constituent properties for the constituents in the constituents array, with the same indices as the constituents array.</p> <p>The <code>ccpp_model_constituents_t</code> type also contains a hash table of constituent properties for more efficient searching, as well as several methods used by the generated cap code. Some methods are highlighted below:</p> <ul> <li>new_field: add a new constituent\u2019s set of metadata fields to the hash table</li> <li>lock_table: lock the constituent hash table and initialize the constituent array<ul> <li>Initializes the constituent array to the default value specified for each constituent (min value held in constituent props array for each constituent)</li> <li>Packs the advected constituents at the front of the constituents array</li> </ul> </li> <li>const_index: retrieves the constituent index for a constituent (provided the standard name)</li> </ul>"},{"location":"design/constituents/#code-generation-python","title":"Code generation (python)","text":"<p>The constituents-related code generation routines provide an interface to the constituents object. These routines can be found in <code>$CAM-SIMA/ccpp_framework/scripts/constituents.py</code>, primarily within the \u201cwrite_host_routines\u201d function. The (most often used) generated routines related to constituents are:</p> <ul> <li>&lt;hostname&gt;_ccpp_register_constituents</li> <li>&lt;hostname&gt;_ccpp_initialize_constituents</li> <li>&lt;hostname&gt;_ccpp_number_constituents</li> <li>&lt;hostname&gt;_constituents_array</li> <li>&lt;hostname&gt;_model_const_properties</li> <li>&lt;hostname&gt;_const_get_index</li> </ul> <p>The routines above are generated during <code>./preview_namelists</code> or <code>./case.build</code> and can be found here: <code>$CASE/bld/atm/obj/ccpp/cam_ccpp_cap.F90</code></p>"},{"location":"design/history/","title":"History &amp; model output","text":"<p>CAM-SIMA history is the mechanism for configuring and generating diagnostic output from a model run. It is also used to generate initial-data files and aids in the model-restart process by saving the state of diagnostic fields whose processing window (e.g., averaging, standard deviation) crosses a restart-write cycle. This page describes the implementation of CAM-SIMA history in CAM-SIMA.</p>"},{"location":"design/history/#history-initialization","title":"History Initialization","text":""},{"location":"design/history/#reading-and-processing-the-history-configuration","title":"Reading and processing the history configuration","text":"<ul> <li>The allowable history configuration keywords are defined in <code>cime_config/hist_config.py</code> in <code>_HIST_CONFIG_ENTRY_TYPES</code>.<ul> <li>Each of the keywords is configurable via the namelist (<code>user_nl_cam</code>)</li> <li>The syntax is <code>&lt;keyword&gt;;&lt;volume&gt;: &lt;value&gt;</code> (see examples below)</li> <li>Currently, these configuration keywords are as follows (the <code>atm_in</code> equivalent indicates how <code>hist_config.py</code> parses these into a namelist to be read by SIMA):</li> </ul> </li> </ul> Configuration Keyword Description atm_in equivalent hist_add_avg_fields hist_add_inst_fieldshist_add_min_fields hist_add_max_field hist_add_var_field hist_remove_fields These configuration keywords add/remove fields to the specified volume with the indicated accumulation flag (average, instantaneous, minimum, maximum, standard deviation). The closest CAM7 equivalent is \u201cfinclX\u201d &amp;hist_config_arrays_nl\u2002hist_num_avg_fields\u2002hist_num_inst_fields\u2002hist_num_min_fields\u2002hist_num_max_fields\u2002hist_num_var_fields&amp;hist_file_config_nl\u2002hist_avg_fields\u2002hist_inst_fields\u2002hist_min_fields\u2002hist_max_fields\u2002hist_var_fields hist_file_type This keyword determines the type of file. Options are: \u201chistory,\u201d \u201csatellite,\u201d and \u201cinitial_value\u201dDefaults to \u201chistory\u201d &amp;hist_file_config_nl\u2002hist_file_type hist_max_frames Indicates the maximum number of samples/frames that can be written to a file before that file is considered \u201cfull\u201d. The CAM7 equivalent is \u201cmfilt\u201d.Defaults to 1 for h0 and 30 for all other volumes. &amp;hist_file_config_nl\u2002hist_max_frames hist_output_frequency Specifies the frequency of writes to the volume. The syntax is \"&lt;integer&gt;*&lt;time period&gt;\" where \u201ctime_period\u201d can be: steps, seconds, minutes, hours, days, months, years. The closest CAM7 equivalent is \u201cnhtfrq\u201d. &amp;hist_file_config_nl\u2002hist_output_frequency hist_precision Denotes the precision for the volume. Options are \"REAL32\" and \"REAL64\".Defaults to \"REAL32\" &amp;hist_file_config_nl\u2002hist_precision hist_write_nstep0 Indicates whether or not to write the nstep=0 sample to the volume.Defaults to .false. &amp;hist_file_config_nl\u2002hist_write_nstep0 hist_filename_template Specifies the template for the filename for the volume.  Defaults to \"%c.cam.%u.%y-%m-%d-%s.nc\" where \"%c\" is the case name, \"%u\" is the volume, \"%y\" is the year, \"%m\" is the month, \"%d\" is the day, and \"%s\" is the number of seconds since midnight GMT, with the timestamp itself representing the model time when the file is created. &amp;hist_file_config_nl\u2002hist_filename_spec <ul> <li><code>hist_config.py</code> also contains the <code>HistoryVolConfig</code> class (all the info pertaining to a single history file), the <code>HistoryConfig</code> class (all the history configuration information including a dict of <code>HistoryVolConfig</code> objects), and helper classes.</li> <li>The <code>HistoryConfig</code> object is created in <code>buildnml</code> out of entries in <code>user_nl_cam</code> and written to <code>run/atm_in</code>.</li> <li>In order to ensure that all relevant runtime (namelist) values show up in <code>atm_in</code>, the <code>HistoryConfig</code> object must contain all the logic in setting default values.</li> </ul>"},{"location":"design/history/#setting-up-the-history-data-structures","title":"Setting up the history data structures","text":"<ul> <li>History namelist information is read and history data structures are set up in <code>src/history/cam_hist_file.F90</code></li> <li>The driving function in <code>cam_hist_file.F90</code> is <code>hist_read_namelist_config</code>, which is called by <code>history_readnl</code> in <code>src/history/cam_history.F90</code>. This function reads in the hist_config_arrays_nl namelist group, allocates the history field arrays, and then uses those arrays to read in the hist_file_config_nl namelist group (via a call to <code>read_namelist_entry</code>).</li> <li>The history configuration namelist options are used to populate <code>cam_history.F90</code>\u2019s module-level hist_configs array of <code>hist_file_t</code> objects (the size of this array is the number of user-configured volumes).</li> <li>The <code>hist_file_t</code> object contains information about the configuration options for a given history volume. This includes the maximum number of frames that can be written to the file, the current number of frames on the file, the name of the file, and all of the history fields to be written to the file. It also contains methods to populate the field lists (<code>config_set_up_fields</code>), set up the metadata of the file (<code>config_define_file</code>), and write history fields to the file (<code>config_write_time_dependent_variables</code>).</li> <li>Each <code>hist_file_t</code> object contains both a hash table and allocatable field list to keep track of the fields written to the file. The core class for each of these is the <code>hist_field_info_t</code> (in <code>src/history/buffers/src/hist_field.F90</code>), which contains information about a history field. This includes the field names, the accumulate flag (average, instantaneous, minimum, etc), units, type, dimensions, and fill value. It also includes the buffer(s) (type is/are <code>hist_buffer_t</code>) that will and do hold the actual data.</li> </ul>"},{"location":"design/history/#populating-the-possible-field-list","title":"Populating the possible field list","text":"<p>The possible fields to be output by the history infrastructure are tracked in <code>cam_history.F90</code> via the <code>possible_field_list</code> hash table. It is populated during init time by calls to the subroutine <code>history_add_field</code> (found in <code>src/history/cam_history.F90</code>). \u201cInit time,\u201d means that all calls to <code>history_add_field</code> must occur during the execution of <code>cam_init</code> (found in <code>src/control/cam_comp.F90</code>).</p> <ul> <li>Within the CCPP physics, this means that any diagnostic fields must be added to possible field list during _init (ideally the diagnostics are kept separate from the core scheme physics to keep the physics portable)</li> <li>Within dynamics, the fields must be added during <code>dyn_init</code> or <code>stepon_init</code></li> <li>For physics variables:<ul> <li>State variables are added to the field list in the init phase of the cam_state_diagnostics scheme in <code>src/physics/ncar_ccpp/diagnostics/cam_diagnostics.F90</code><ul> <li>This scheme is included at the end of the <code>physics_before_coupler</code> group in the suite definition file (SDF)</li> </ul> </li> <li>Tendency variables are added to the field list in the init phase of the <code>cam_tend_diagnostics</code> scheme in <code>src/physics/ncar_ccpp/diagnotics/cam_diagnostics.F90</code><ul> <li>This scheme is included at the end of the <code>physics_after_coupler</code> group in the SDF</li> </ul> </li> <li>Additional variables specific to the scheme are included in the init phase of a _diagnostics scheme in <code>src/physics/ncar_ccpp/diagnostics</code> <p>Each call to <code>history_add_field</code> adds a new field to the end of the <code>possible_field_list_head</code> linked list. At the end of <code>cam_init</code>, the possible field list linked list is used to print the list (to the atm.log* file) and then is converted to the <code>possible_field_list</code> hash table. A sample of the history field list is seen below.</p> <pre><code>  ***************** HISTORY FIELD LIST ******************\n             T          K  avg  air_temperature\n            ZM          m  avg  geopotential_height_wrt_surface\n          PHIS     m2 s-2  ins   surface_geopotential\n          PMID         Pa  avg  air_pressure\n       PDELDRY         Pa  avg  air_pressure_thickness_of_dry_air\n             Q    kg kg-1  avg  water_vapor_mixing_ratio_wrt_moist_air_and_condensed_water\n        CLDLIQ    kg kg-1  avg cloud_liquid_water_mixing_ratio_wrt_moist_air_and_condensed_water          \n        RAINQM    kg kg-1  avg  rain_mixing_ratio_wrt_moist_air_and_condensed_water\n         TTEND      K s-1  avg  tendency_of_air_temperature_due_to_model_physics\n  *************** END HISTORY FIELD LIST ****************\n</code></pre>"},{"location":"design/history/#capturing-history-output","title":"Capturing history output","text":"<p>Outside of CAM-SIMA init and finalize time, history buffers can be populated with data via a call to <code>history_out_field</code> (found in <code>src/history/cam_history.F90</code>)</p> <p>The subroutine <code>history_out_field</code> iterates over the <code>hist_configs</code> array and populates the buffer(s) of the <code>hist_field_info_t</code> object of the <code>hist_file_t</code> object if the field name in the call is active on that file (e.g. the field was configured via the namelist to be output for that volume).</p> <ul> <li>Within the CCPP physics, calls to <code>history_out_field</code> can exist anywhere except _init and _final</li> <li>In dynamics, calls to <code>history_out_field</code> can exist anywhere except in <code>dyn_init</code>, <code>stepon_init</code>, and <code>stepon_final</code></li> <li>For physics variables, <code>history_out_field</code> calls are included in the run phase of the same schemes described in the section above.</li> </ul>"},{"location":"design/history/#defining-new-history-files","title":"Defining new history files","text":"<p>The <code>cam_history.F90</code> subroutine <code>history_write_files</code> (which is called during <code>cam_timestep_final</code>) does three main actions for each of the user-defined history volumes:</p> <ol> <li>Determine if it\u2019s time to write to the file based on the user-supplied namelist option hist_output_frequency</li> <li>If it's time to write, determine if we need to open a new file</li> <li>Write the variables to the file(s)</li> </ol> <p>The bolded step #2 above is what determines if we need to define a new history file. The situations where we would need to define a new file are:</p> <ol> <li>It's the first sample we're outputting to a specific volume.</li> <li>The last time we output to the volume, we \"filled\" the file (number of samples written to the file met the user-configured <code>hist_max_frames</code>) and closed it</li> </ol> <p>We determine if it's time for a new file with the following line of code:</p> <pre><code>   mod(num_samples, hist_configs(file_idx)%max_frame()) == 0\n</code></pre> <p>If it is indeed time to define a new file, we call the <code>config_define_file</code> subroutine (which is found in <code>src/history/cam_hist_file.F90</code>) for the volume:</p> <pre><code>  call hist_configs(file_idx)%define_file(restart, logname, host, model_doi_url)\n</code></pre> <ul> <li>This subroutine opens the netcdf file(s) and writes the necessary time-independent metadata (for the file and for the history fields) and grid information.<ul> <li>Note that there will be a maximum of TWO (2) files opened at this stage. If there are both instantaneous fields AND accumulated fields (average, minimum, maximum, standard deviation) on the volume, two files will be created (hXi AND hXa); otherwise, only the relevant file will be created (hXi OR hXa)</li> </ul> </li> </ul>"},{"location":"design/history/#writing-a-history-file","title":"Writing a history file","text":"<p>The <code>cam_history.F90</code> subroutine <code>history_write_files</code> (which is called during <code>cam_timestep_final</code>) does three main actions for each of the user-defined history volumes:</p> <ol> <li>Determine if it\u2019s time to write to the file based on the user-supplied namelist option hist_output_frequency</li> <li>If it's time to write, determine if we need to open a new file</li> <li>Write the variables to the file(s)</li> </ol> <p>The bolded step #3 above occurs any time the criteria for #1 is satisfied. At this point, the following call is made to write the history fields (whose data has been stored in their buffers via calls to <code>history_out_field</code>):</p> <pre><code>  call hist_configs(file_idx)%write_time_dependent_variables(file_idx, restart)\n</code></pre> <p>It is during this call that we increment the number of samples written for this volume and actually write the data held within the buffer(s) to the netcdf file (as well as the time-dependent metadata for the fields).</p>"},{"location":"design/history/#defining-history-restart-files","title":"Defining history restart files","text":"<p>Restarts not yet implemented in CAM-SIMA</p>"},{"location":"design/history/#writing-a-history-restart-file","title":"Writing a history restart file","text":"<p>Restarts not yet implemented in CAM-SIMA</p>"},{"location":"design/history/#reading-a-history-restart-file","title":"Reading a history restart file","text":"<p>Restarts not yet implemented in CAM-SIMA</p>"},{"location":"design/sima-design-goals/","title":"Design goals &amp; features","text":"<p>Motivated by the Singletrack project (a precursor to SIMA), the CAM-SIMA project was created to build a new CAM infrastructure to meet the SIMA science and computational needs. This page documents those needs and some of the features that implement them.</p>"},{"location":"design/sima-design-goals/#cam-needs-to-be-more-run-time-configurable","title":"CAM needs to be more run-time configurable","text":"<ul> <li>To make CAM and CESM more available, e.g., for usage in containers and the cloud, a build of CAM should be more configurable than it is at present.</li> <li>One feature that makes CAM more run-time configurable is moving physics suites to the CCPP. By allowing CAM to compile in more than one physics suite, the physics suite can be selected at run time (e.g., as a namelist variable).</li> <li>Another feature needed to make CAM more run-time configurable is making dycores themselves more run-time configurable. For instance, the SE dycore will no longer require the number of advected constituents to be specified at compile time.</li> </ul>"},{"location":"design/sima-design-goals/#remove-obstacles-to-use-of-specialized-high-performance-processing-units-eg-gpus-fpgas","title":"Remove obstacles to use of specialized high-performance processing units (e.g., GPUs, FPGAs)","text":"<p>The chunk structure in CAM physics served its purpose when threading was the only way to accelerate code. However, to make the best use of both threading and modern accelerators, a flexible chunking mechanism is required. The new infrastructure enables this by using flat arrays for all fields.</p> <ul> <li>Moving to flexible precision of data is important for being able to test both performance improvements and the affect on model quality. The CCPP is explicitly designed to allow for compile-time selection of precision at the physics suite level as well as for individual fields. In addition, the new infrastructure is explicitly designed to handle the case where the dycore is running at a different precision than the physcs (i.e., by using proper field promotion and demotion primitives).</li> <li>Pointers in Fortran are less efficient because they prevent some optimization techniques. The new infrastructure avoids pointers as much as possible by making use of the automatic data management capability of the CCPP (which does not create pointers).</li> <li>The new infrastructure provides greater flexibility in that the model can be built with multiple physics suites to increase run-time flexibility. There is a tradeoff in that building more physics suites will often increase build time. Builds with a single suite should be faster than now since only the schemes that are required for the suite are compiled (currently most schemes are compiled all the time even if they will not be used).</li> </ul>"},{"location":"design/sima-design-goals/#modularity","title":"Modularity","text":"<p>In order to continue to allow CAM to grow without an ever increasing cost of bringing in new features, CAM must be more modular. A classic example is chemistry which ACOM would like to make modular but which is currently entwined with CAM in many areas (e.g., code in CAM repository, extensive configuration code dedicated to chemistry, extensive namelist building code and data dedicated to chemistry, large number of use cases containing chemistry configuration data). The new CAM infrastructure contains features to increase modularity.</p> <ul> <li>Support for multiple namelists. This allows modular components to contain their own namelist (run-time configuration options). The active namelists are combined to produce atm_in.</li> <li>Flexible handling of constituent information. Modular components can provide constituent information via metadata (if component is a CCPP scheme) or at run time.</li> </ul> <p>Modularity will allow CAM to move components to external repositories. This process cuts development costs for both CAM and for the component (e.g., as has happened with PUMAS). Some ways this is accomplished are listed here:</p> <ul> <li>Code reviews are more efficient since CAM SEs do not have to review every routine in the external module so they can just focus on the interfaces. The external developers do not have to be involved in CAM modifications.</li> <li>Externals can develop and maintain they own namelist definition files, they do not have to coordinate with the larger CAM namelist (which itself has been broken into several smaller namelists).</li> <li>Namelists associated with physics schemes do not have to have separate namelist-reading code. The new infrastructure automatically creates an appropriate Fortran module to read in the runtime data from atm_in. The system then also ensures that all active namelists are called at run time. This process ensures that namelists are always read correctly while not requiring coding or reviews to keep up to date with namelist changes.</li> </ul> <p>Use of the CCPP to build physics suites also makes CAM more modular because the CCPP treats physics schemes as modular which allows flexibility in building physics suites. The CCPP takes care of making sure variables are available before they are used and also builds the code currently handled via hand-written code in the various versions of physpkg.F90.</p>"},{"location":"design/sima-design-goals/#run-time-data-checking","title":"Run-time data checking","text":"<p>CAM needs data to run but the data needs vary with the simulation. The new infrastructure facilitates this.</p> <ul> <li>Before running physics, the new infrastructures queries the physics suite as to what input fields are required (using a CCPP interface). Then it makes sure that all of these fields have been initialized or reads the values from the initial data file. Any uninitialized fields that are not found on the initial data file will trigger a run-time error.</li> </ul>"},{"location":"design/sima-design-goals/#efficient-offline-testing-and-simulation","title":"Efficient offline testing and simulation","text":"<p>CAM currently has a few ways to run offline testing (e.g., SCAM, PORT). The new infrastructure builds these capabilities in for more efficient and flexible use.</p> <ul> <li>The new infrastructure has the ability to run without a dycore.</li> <li>Offline mode (NULL dycore) can be run with any number of columns.</li> <li>Offline mode does not required gridded input.</li> </ul>"},{"location":"design/sima-design-goals/#software-quality-control","title":"Software quality control","text":"<p>To enable efficient quality control, the new infrastructure implements a number of continuous integration (CI) techniques.</p> <ul> <li>To implement all the flexibility mentioned above, the new infrastructure makes extensive use of python scripts.<ul> <li>Python scripts make extensive use of python doctests (for simpler tests).</li> <li>There are python unit tests to cover more complicated situations.</li> <li>The GitHub CI also runs a static analysis tool (pylint) to provide feedback on potential coding issues.</li> <li>Python tests can easily be run by hand but are also automatically run on GitHub</li> </ul> </li> <li>The new infrastructure will use offline mode (see above) to run many physics configurations quickly without requiring large machines.<ul> <li>This will enable quick testing during development on a laptop.</li> <li>We hope many of these tests can also be run automatically on GitHub.</li> </ul> </li> </ul>"},{"location":"development/cam-coding-standards/","title":"Coding standards","text":"<p>The standards in this document are largely prescriptive, i.e., they should be followed.</p> <ul> <li>MUST: Exceptions must be discussed and agreed to by the CAM SEs and noted in this document.</li> <li>SHOULD: Exceptions must be approved by the CAM SEs and documented in the ChangeLog.</li> </ul> <p>While some legacy code will not follow these rules, efforts SHOULD be made to improve the code whenever you are working on it (e.g., bug fixes, enhancements).</p>"},{"location":"development/cam-coding-standards/#general-coding-standards","title":"General coding standards","text":""},{"location":"development/cam-coding-standards/#must","title":"MUST","text":"<ul> <li>Always use spaces instead of tabs</li> <li>No trailing spaces (i.e., no spaces at the end of a line)</li> </ul> <p>See tips for configuring editors</p>"},{"location":"development/cam-coding-standards/#should","title":"SHOULD","text":"<ul> <li>Use comments to explain the purpose of the following code and/or include any important but non-obvious information. When working with code, always check the comments to make sure they are still correct and useful.</li> <li>Do not use comments to 'save code for later in case it might be useful'.</li> <li>Do not include a comment that merely restates the following code logic (e.g., 'Loop over variables')</li> </ul>"},{"location":"development/cam-coding-standards/#python-coding-standards","title":"Python coding standards","text":"<p>We expect all python code to pass with a perfect score (10) using <code>pylint</code> with this version of <code>pylintrc</code>. However, external repos may have their own <code>pylintrc</code> version depending on their needs.</p> <p>We also expect all python files to follow the black code style and format.</p> <p>Finally, one can also follow the Google Python Style Guide.</p>"},{"location":"development/cam-coding-standards/#fortran-coding-standards","title":"Fortran coding standards","text":"<p>The standards described in this section represent the CAM Fortran standards. Other Fortran standards:</p> <ul> <li>CTSM Fortran Standards</li> <li>MOM Fortran Standards</li> </ul>"},{"location":"development/cam-coding-standards/#must_1","title":"MUST","text":"<ul> <li>No naked <code>use</code> statements</li> <li>No continued single-line <code>if</code> statements (i.e., all <code>if</code> statements should have a <code>then</code> if the statement is on more than one line)</li> <li>Every namelist variable in each active namelist group is present in the namelist file. An active namelist group is one which may be read during the current run.</li> <li>All namelist variables except for logical quantities are initialized to invalid values (integer: <code>-HUGE(1)</code>, real: <code>NaN</code>, character: <code>'UNSET'</code>).</li> <li>Functions may not have side effects, and should include the <code>pure</code> keyword.</li> <li>Do not combine statements on a single line (i.e., avoid use of the semi-colon to combine statements).</li> <li>Use <code>intent</code> for dummy arguments except for pointers.</li> <li>All variables of type real must have a specified kind, including literals.  For example, use <code>1.5_r8</code>, not <code>1.5</code> or <code>1.5D0</code>. Literals must also include the decimal point.</li> <li>All character declarations must use Fortran 90+ syntax (e.g., <code>character(len=*)</code> or <code>character(len=CL)</code>).</li> <li>All variable declarations must use Fortran 90+ syntax (i.e., must include the double colon between the attributes and the variable name).</li> <li>All type and procedure declarations must use Fortran 90+ syntax (i.e., must include the double colon before the type or procedure name).</li> <li>All modules should include an <code>implicit none</code> statement in the preamble (after the <code>use</code> statements). Module routines then do not need this statement.</li> <li>All optional arguments must be passed via keyword (e.g. use <code>call subroutine(x, optional_y=y)</code> instead of <code>call subroutine(x, y)</code> for the optional variable <code>optional_y</code>).</li> <li>Initialize local (non-parameter) variables in subroutines and functions at the top of the executable code, NOT on a variable declaration lines.<ul> <li>Initializing a local variable on a declaration line invokes the <code>SAVE</code> attribute and is not thread safe.</li> <li>Local pointer variables MUST be initialized before other (non-initialization) statements. By default, use the <code>nullify</code> statement.</li> </ul> </li> <li>All variables that are on the physics grid must have their horizontal dimension declared with <code>pcols</code>, even if only a subset of the variable is used in the subroutine or function. </li> </ul>"},{"location":"development/cam-coding-standards/#should_1","title":"SHOULD","text":"<ul> <li>Avoid use of preprocessor directives (e.g., <code>#if</code>, <code>#ifdef</code>). Always try for runtime variable logic instead.</li> <li>Keep formula statements relatively short. Use temporary variables to break long formulas into easier-to-read sections.</li> <li>Use subroutines to avoid repeated (cut and paste) code logic.</li> <li>Avoid side effects in subroutines. Pass variables to routines instead of 'using' them from elsewhere.  </li> <li>Use the <code>pure</code> keyword if a subroutine has no side effects.</li> <li>List dummy arguments one per line, however, related items may be grouped.</li> <li>Dummy argument order should match the order in the argument list.</li> <li>Use symbolic numerical comparison operators (e.g., <code>==</code>, <code>/=</code>, <code>&lt;</code>, <code>&gt;=</code>) not old character versions (e.g., <code>.eq.</code>).</li> <li>Avoid the use of pointers as dummy arguments (exceptions must be discussed in design or code review)</li> <li>Modules should be default <code>private</code>. Public interfaces are declared after the <code>private</code> declaration.</li> <li><code>private</code> module interfaces (i.e., subroutines and functions) should be declared private in the module header.</li> <li>Module names should conform to their filename (i.e., the module name should be the filename without the <code>.F90</code>).</li> <li>Functions should use the <code>pure</code> attribute. If they cannot, the reason should be included as a comment in the function's preamble.</li> <li>All functions and subroutines should avoid un-necessary statements (e.g. a blank <code>return</code> at the end of a subroutine).</li> <li><code>use</code> statements should be brought in at the smallest scope possible (e.g. inside individual subroutines instead of at the module level).</li> </ul>"},{"location":"development/cam-coding-standards/#indentation-and-style","title":"Indentation and style","text":"<ul> <li>Scoping: Indentation should follow scope. That is, whenever entering a new scope (e.g., <code>module</code>, <code>subroutine</code>, <code>if</code>, <code>do</code>), indent that scope relative to the scoping statement (recommended 3 spaces but each module should at least be self consistent).</li> <li>A single line should be less than 133 characters long.</li> <li>Continue lines: Indent continue lines 5 spaces or align with similar lines in statement.</li> <li>Use spaces to ease reading statements (e.g., before and after operators, after commas except in a dimensions list)</li> <li>Include a space after <code>if</code>, <code>else</code>, <code>end</code>, <code>do</code>, and <code>while</code>.</li> <li>Include a space before and after <code>::</code></li> <li>No space after <code>only</code>, i.e., <code>only:</code>, not <code>only :</code>.</li> <li>When aligning code for readability, commas go immediately after a symbol (no space).</li> </ul>"},{"location":"development/cam-coding-standards/#tips-for-configuring-editors","title":"Tips for configuring editors","text":""},{"location":"development/cam-coding-standards/#emacs-add-to-your-emacs-file","title":"emacs (add to your <code>.emacs</code> file)","text":"<ul> <li>To automatically remove trailing spaces whenever you save a file:</li> </ul> <pre><code>(add-hook 'before-save-hook 'delete-trailing-whitespace)\n</code></pre> <ul> <li>To automatically indent with spaces instead of tabs:</li> </ul> <pre><code>(setq-default indent-tabs-mode nil)\n</code></pre> <ul> <li>To use 4 spaces for each indent:</li> </ul> <pre><code>(setq tab-width 4)\n</code></pre>"},{"location":"development/cam-coding-standards/#vi-add-to-your-vimrc-file","title":"vi (add to your <code>.vimrc</code> file)","text":"<ul> <li>To automatically remove trailing spaces whenever you save a file:</li> </ul> <pre><code> autocmd BufWritePre * :%s/\\s\\+$//e\n</code></pre>"},{"location":"development/cam-testing/","title":"Testing","text":"<p>This page describes the various automated and manual tests that are run for CAM-SIMA whenever the code is modified, as well as instructions for how to add new tests.</p>"},{"location":"development/cam-testing/#python-unit-testing","title":"Python unit testing","text":"<p>CAM-SIMA supports two kinds of python unit tests, <code>doctest</code> and <code>unittest</code> tests, both of which are part of the standard python library.  </p> <p>All <code>unittest</code> tests should  be in:</p> <p><code>CAM-SIMA/test/unit</code></p> <p>while all files used by the tests should be in:</p> <p><code>CAM-SIMA/test/unit/sample_files</code></p> <p>All <code>unittest</code> tests are automatically run via Github Actions whenever a Pull Request (PR) is opened, modified, or merged.  </p> <p>All <code>doctest</code> tests are also run automatically as long as the scripts they are located in are under <code>CAM-SIMA/cime_config</code> or <code>CAM-SIMA/src/data</code>.</p> <p>To manually run all of the unit tests at any time, simply run the following shell script:</p> <p><code>CAM-SIMA/test/run_tests.sh</code></p> <p>Finally, when adding new tests, determine if the test can be done in only a few lines with minimal interaction with external files or variables.  If so, then it would likely be best as a <code>doctest</code>.  Otherwise it should be a <code>unittest</code> test.  Failure to follow this rule of thumb could result in test failures in the Github Actions workflow.  Also remember to add your new tests to the <code>run_tests.sh</code> script so future users can easily run the tests manually.</p>"},{"location":"development/cam-testing/#static-source-code-analysis","title":"Static Source Code Analysis","text":""},{"location":"development/cam-testing/#python","title":"Python","text":"<p>Any python script which is added or modified via a PR will automatically be analyzed using <code>pylint</code>, and must have a score of 9.5 or greater in order to not be marked as a test failure.  The hidden <code>pylintrc</code> file used for the analysis can be found here:</p> <p><code>CAM-SIMA/test/.pylintrc</code></p> <p>Users can also manually run <code>pylint</code> against the core python build scripts by running the following shell script:</p> <p><code>CAM-SIMA/test/pylint_test.sh</code></p> <p>Please note that <code>pylint</code> is not part of the standard python library, and so it may need to be installed before being able to run the shell script.</p>"},{"location":"development/cam-testing/#regression-testing","title":"Regression Testing","text":""},{"location":"development/cam-testing/#running-the-regression-tests-manual","title":"Running the regression tests (manual)","text":"<p>NOTE:  Regression testing on Derecho should be done for every PR before merging!</p> <p>Users can manually run regression tests on Derecho to ensure that the model builds correctly in various configurations.  The tests can be run with a local copy of CAM-SIMA by using the <code>test_driver.sh</code> script under <code>$CAM-SIMA/test/system</code>.  To run the tests associated with a particular compiler option one can do the following commands:</p> <p>For running GNU tests*:</p> <pre><code>env CAM_FC=gnu ./test_driver.sh -f\n</code></pre> <p>For running Intel tests*:</p> <pre><code>env CAM_FC=intel ./test_driver.sh -f\n</code></pre> <p>Running the script will produce a directory in your scratch space labeled <code>aux_sima_&lt;CAM_FC&gt;_&lt;timestamp&gt;</code>, where <code>&lt;CAM_FC&gt;</code> is the compiler you chose, and <code>&lt;timestamp&gt;</code> is the timestamp (starting with the date) of when the tests were started, along with a job submitted to the local batch system.</p> <p>Inside the directory you should see an executable labeled <code>cs.status.*</code>.  Running that command after the submitted job has finished will display the test results.  Currently for all tests everything should be labeled <code>PASS</code> except the <code>SUBMIT</code> step, which should be labeled <code>PEND</code>.  Any other label indicates that a test may have failed, and should be investigated.</p> <p>Finally, the tests themselves are listed in <code>&lt;CAM-SIMA&gt;/cime_config/testdefs/testlist_cam.xml</code>.  Any files that need to be included in order for the tests to run properly are located in <code>&lt;CAM-SIMA/cime_config/testdefs/testmods_dirs/cam/outfrq_XXX</code>, where <code>XXX</code> is the name of the test.  Additional information on the CIME testing system, which is what this testing infrastructure is built on, can be found online here. </p> <p>*Note: you may also have to include the environment variable <code>CAM_ACCOUNT</code> on derecho, which points to your account key</p>"},{"location":"development/cam-testing/#adding-a-new-regression-test","title":"Adding a new regression test","text":"<p>The test list can be found here: <code>$CAM-SIMA/cime_config/testdefs/testlist_cam.xml</code></p> <ul> <li>If you are adding a new machine, compiler or category for an existing test, add a new <code>&lt;machine&gt;</code> XML entry</li> <li>If you are adding a fully new test, add a new <code>&lt;test&gt;</code> XML entry with the following structure:</li> </ul> <pre><code>&lt;test compset=\"&lt;COMPSET_NAME&gt;\" grid=\"&lt;GRID_ALIAS&gt;\" name=\"&lt;TEST_TYPE&gt;_&lt;TEST_MOD&gt;\" testmods=\"&lt;RELPATH_TO_TESTMODS_DIR&gt;\"&gt;\n  &lt;machines&gt;\n    &lt;machine name=\"&lt;MACH_NAME&gt;\" compiler=\"&lt;COMPILER&gt;\" category=\"&lt;TEST_CATEGORY&gt;\"/&gt;\n  &lt;/machines&gt;\n  &lt;options&gt;\n    &lt;option name=\"comment\"&gt;COMMENT HERE&lt;/option&gt;\n    &lt;option name=\"wallclock\"&gt;WALLCLOCK_TIME&lt;/option&gt;\n  &lt;/options&gt;\n&lt;/test&gt;\n</code></pre> <ul> <li><code>&lt;COMPSET_NAME&gt;</code>: component set alias (or long name) - you can see more about compsets here</li> <li><code>&lt;GRID_ALIAS&gt;</code>: model grid/resolution you'd like to run on - you can see more about grids here</li> <li><code>&lt;TEST_TYPE&gt;</code>: type of test to be run. You can find the testing types here.</li> <li><code>&lt;TEST_MOD&gt;</code>: test modifier that changes the default behavior of the test type. More here</li> <li><code>&lt;RELPATH_TO_TESTMODS_DIR&gt;</code>: relative path to the testmods directory for this run; usually looks something like <code>\"cam/some_directory_name/\"</code><ul> <li>The testmods directory will contain any namelist mods and XML configuration variable changes for the test (<code>user_nl_cam</code> and/or <code>shell_commands</code>)</li> <li>testmods directories can be found in <code>$CAM-SIMA/cime_config/testdefs/testmods_dirs/cam/</code></li> </ul> </li> <li><code>&lt;MACH_NAME&gt;</code>: machine name - will almost definitely be either <code>derecho</code> or <code>izumi</code></li> <li><code>&lt;COMPILER&gt;</code>: compiler to be used (options: <code>gnu</code>, <code>nag</code>, <code>intel</code>, <code>nvhpc</code>)</li> <li><code>&lt;TEST_CATEGORY&gt;</code>: group of tests that this test belongs to - the default run by <code>test_driver.sh</code> is <code>aux_sima</code> (which is run for each PR to CAM-SIMA)</li> <li><code>WALLCLOCK_TIME</code>: maximum amount of time that the job will be allowed to run</li> </ul> <p>Here is an example test entry for a 2-timestep smoke test of kessler physics on the MPAS grid, run with both intel and gnu </p> <pre><code>  &lt;test compset=\"FKESSLER\" grid=\"mpasa480_mpasa480\" name=\"SMS_Ln2\" testmods=\"cam/outfrq_kessler_mpas_derecho_nooutput/\"&gt;\n    &lt;machines&gt;\n      &lt;machine name=\"derecho\" compiler=\"intel\" category=\"aux_sima\"/&gt;\n      &lt;machine name=\"derecho\" compiler=\"gnu\" category=\"aux_sima\"/&gt;\n    &lt;/machines&gt;\n    &lt;options&gt;\n      &lt;option name=\"wallclock\"&gt;00:10:00&lt;/option&gt;\n      &lt;option name=\"comment\"&gt;GNU build test for MPAS dycore (with Kessler physics)&lt;/option&gt;\n    &lt;/options&gt;\n  &lt;/test&gt;\n</code></pre>"},{"location":"development/debugging/","title":"Debugging techniques","text":"<p>Start with the CAM wiki.</p>"},{"location":"development/debugging/#cam-sima-specific-debugging","title":"CAM-SIMA-specific debugging","text":""},{"location":"development/debugging/#build-errors","title":"Build errors","text":"<p>Debugging tips if you get build errors:</p> <ul> <li>If the output indicates that the error message or failure is coming from somewhere within $CAM-SIMA/ccpp_framework:<ul> <li>If you're getting a clear error message, it's likely that you have something wrong with your metadata</li> <li>If you're getting an error message that indicates that something is breaking in the framework code itself (something went uncaught) - consult the AMP SEs</li> </ul> </li> <li>If the error happens during the atm build, you can see the full output of the atm build in the build log here: <code>bld/atm.bldlog.*</code></li> </ul>"},{"location":"development/debugging/#run-time-errors","title":"Run-time errors","text":"<ul> <li>Start with the atm.log* - if the issue occurred during the execution of the CAM code, it will hopefully have a clear and concise error message</li> <li>Move to the cesm.log* - it will hopefully include a stack trace for the error in question; if the error did not occur in the CAM code (or CAM did not properly trap the error), it will help you identify the source of the issue.</li> <li>If neither log file contains helpful information, a few first steps:<ul> <li>Resubmit the case; it could be a machine hiccup</li> <li>Turn on DEBUG mode (if it's not on already) and rebuild/rerun</li> <li>Look in your run directory for any log files called <code>PETXXX</code> - if there was an issue on the ESMF side of things, it will show up in one of these (there will be one PET file per processor)</li> <li>Try a different compiler - maybe it'll give you a more helpful error message</li> <li>set NTASKS=1 (<code>./xmlchange NTASKS=1</code>), do a clean rebuild (as instructed), and run again; maybe running in serial will identify the error</li> <li>Look for the <code>***************** HISTORY FIELD LIST ******************</code> in the atm.log* file; if it's not there, the error occurred at init time<ul> <li>If the error occurred during init time, try a new case with a different grid and/or dycore</li> <li>If the model ran for a few timesteps before dying (look for the <code>CAM-SIMA time step advanced</code> message in the atm.log* file), it's likely that one or more variable that you introduced or modified has gone off the rails (value has become very large or very small or zero)<ul> <li>Update your user_nl_cam to output all possible suspected variables to a history file at some point shortly before the model dies, then inspect the output to see if any are obviously wrong</li> </ul> </li> <li>If the model completed all timesteps, try running a shorter case to see if the problem persists; if so, it's an error during the model finalization</li> </ul> </li> <li>Run the TotalView debugger on izumi</li> <li>Use the old standard - print statements - to narrow down where the code is stopping</li> <li>Ask for help!</li> </ul> </li> </ul>"},{"location":"development/debugging/#unexpected-answer-changes","title":"Unexpected answer changes","text":"<ul> <li>Two paths here:<ul> <li>You're getting unexpected DIFFs from the regression testing<ul> <li>Consult with a scientist about whether differences are expected and for which configurations (compsets, resolutions, namelists parameters, etc)</li> <li>If the differences are very small (look like round-off), consult with the other AMP SEs on whether we're ok with this</li> <li>If the differences are indeed unexpected and larger than round-off, create a case using the code from the head of <code>development</code> and:<ul> <li>place print statements in both code bases (your development branch and the head of <code>development</code>) to identify where the numbers are going awry OR</li> <li>run the TotalView debugger OR</li> <li>use the comparison tool described below (<code>$CAM-SIMA/tools/find_max_nonzero_index.F90</code>)</li> </ul> </li> </ul> </li> <li>You're getting unexpected answer changes compared with CAM<ul> <li>Consult with other AMP SEs about whether the differences appear to be due to round-off error</li> <li>Use the comparison tool (LINK ONCE IT EXISTS): <code>$CAM-SIMA/tools/find_max_nonzero_index.F90</code><ul> <li>This tool can help you narrow down where the issue begins by printing out values at a specific index and comparing those with the \"truth\" (from CAM)</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"development/debugging/#totalview","title":"TotalView","text":"<p>(COURTNEY - ASK CHERYL TO HELP WITH THIS)</p> <ul> <li>Create and configure a new case (using gnu and only 1 task)</li> <li>Build the case (<code>./case.build</code>)</li> <li>Run command <code>bash</code> to change to bash (if not already)</li> <li>Run the following commands:</li> </ul> <pre><code>np=1\nnthreads=1\n\nsource .env_mach_specific.sh\n\nRUNDIR=`./xmlquery RUNDIR -value`\nEXEROOT=`./xmlquery EXEROOT -value`\nLID=`date '+%y%m%d-%H%M%S'`\n\ncd $RUNDIR\nmkdir timing\nmkdir timing/checkpoints\necho `pwd`\nexport OMP_NUM_THREADS=$nthreads\ntotalview ${EXEROOT}/cesm.exe\n</code></pre> <ul> <li><code>exit</code> to exit the totalview window and give up the node </li> </ul>"},{"location":"development/git-basics/","title":"Working with git and GitHub","text":""},{"location":"development/git-basics/#getting-started-with-git","title":"Getting started with git","text":"<ul> <li>For a quick, visual introduction to git, try a 5 Minute Overview of Git on Youtube</li> <li>Need an introduction to version control along with git and GitHub? Try Git and GitHub for Poets, a Youtube series</li> <li>For a glossary of common terms used in git and GitHub documentation, see the GitHub glossary.</li> <li>GitHub's Git Handbook offers a brief overview of git and GitHub, including example workflows and links to more in-depth resources.</li> <li>Software Carpentry offers a hands-on introduction to git.</li> <li>A highly-regarded, comprehensive git reference is the book Pro Git (available as a book or a free pdf).<ul> <li>The first three chapters of Pro Git, along with sections 6.1 and 6.2 on GitHub, are particularly useful if you're getting started with git. [1]</li> <li>The site also contains links to git reference pages along with introductory videos on git.</li> <li>You can skip the last section of chapter 3, on rebasing, until you have more experience with git. It's easy to cause problems for yourself or others with rebasing so only use rebasing in CAM-SIMA following the workflow instructions below as rebasing rewrites history, which can make it impossible to reproduce exactly what you have done before.</li> </ul> </li> <li>For a clear introduction to git internals, try Dissecting Git Guts by Emily Xie.</li> <li>Git from the inside out is a blog post with accommpaning video from Mary Rose Cook that looks under the covers a bit to show what happens when you execute git commands.</li> <li>Git from the Bottom Up by Josh Wiegley provides a quick glossary of the main terms describing a git repository with links to detailed descriptions. Good site for reminders about a git concept.</li> <li>Need to really understand the science behind how git works? Try Advanced Git: Graphs, Hashes, and Compression, Oh My! by Matthew McCullough</li> </ul> <p>Git also offers extensive built-in (i.e., command line) help, although it can be hard to understand until you are familiar with basic git concepts:</p> <p><code>git help</code></p> <p><code>git help COMMAND</code></p> <p>man gittutorial</p> <p>man giteveryday</p>"},{"location":"development/git-basics/#how-to-set-up-your-git-development-environment","title":"How to set up your git development environment","text":"<p>There are several stages in setting up your git and GitHub development environment. Below, they are broken into three sections which represent the different stages:</p> <ul> <li>One time GitHub setup</li> <li>Set up git environment on new machine</li> <li>Working with clones</li> </ul>"},{"location":"development/git-basics/#one-time-github-setup","title":"One time GitHub setup","text":"<ol> <li>Set-up personal github account (if one does not already exist): https://github.com</li> <li> <p>Create a new personal CAM-SIMA fork of the ESCOMP/CAM-SIMA repo:</p> <p></p> </li> <li> <p>Set up SSH keys on GitHub (optional):</p> <p>If you will be pushing changes to GitHub (either to your own fork or to shared forks), or if you will be pulling changes from private repositories on GitHub, then it's worth the time to set up ssh keys for each machine you'll be using. By doing so, you won't have to enter your password when pushing to or pulling from GitHub.</p> <p>See here for instructions. After doing this, you can use the ssh form of GitHub URLs (e.g., <code>git@github.com:ESCOMP/cam-sima.git</code>) in place of the <code>https</code> form.</p> </li> <li> <p>Configure GitHub notifications (optional): It is important to keep track of activity on GitHub but there are ways to manage how you are notified.</p> <ul> <li>Controlling how you receive notifications: Click on your profile picture in the upper-right of any GitHub page, then click on \"Settings\", and then on \"Notifications\". You will see several options, here are a few recommended settings:<ul> <li>Automatically watch repositories: Yes (check box)</li> <li>Participating: Email</li> <li>Watching: Web</li> </ul> </li> <li>To see and manage Web notifications: Click on the bell in the upper right of any GitHub page to see Web notifications and to manage which repositories you are watching. There will be a blue dot on the bell if there are new (unread) notifications).</li> </ul> </li> </ol>"},{"location":"development/git-basics/#set-up-git-environment-on-new-machine","title":"Set up git environment on new machine","text":"<p>git has global settings which apply to all repository clones on your machine. These settings reside in a file called <code>.gitconfig</code> in your home directory. Below are some required and some optional but recommended global git settings to apply to any new machine where you will do CAM-SIMA development (e.g., Derecho, Izumi, personal laptop). Apply the settings below or simply copy a <code>.gitconfig</code> file from a machine that is already configured.</p>"},{"location":"development/git-basics/#required-git-global-configuration-settings","title":"Required git global configuration settings","text":"<pre><code>git config --global user.name \"Your Name\"\ngit config --global user.email &lt;GitHub email address&gt;\n</code></pre> <p>We recommend that you use your UCAR email address as your GitHub email address but if you use another address, you can add your UCAR email address by clicking on your profile picture in the upper-right of any GitHub page, then clicking on \"Settings\", and then on \"Emails\".</p>"},{"location":"development/git-basics/#recommended-git-global-configuration-settings","title":"Recommended git global configuration settings","text":"<p>You can set which editor to use for log messages, etc., with:</p> <pre><code>git config --global core.editor &lt;editor of your choice: emacs, vi, vim, etc&gt;\n</code></pre> <p>(See http://swcarpentry.github.io/git-novice/02-setup for specific settings to use for many common editor choices.)</p> <p>The following setting generates better patches than the default:</p> <pre><code>git config --global diff.algorithm histogram\n</code></pre> <p>The following setting makes it easier to resolve conflicts if you're doing conflict resolution by hand as opposed to with a dedicated conflict resolution tool. Without this setting, you'll just see your version and the version you're merging in delimited by conflict markers. With this setting, you'll also see the common ancestor of the two sides of the merge, which can make it much easier to figure out how to resolve the conflict:</p> <pre><code>git config --global merge.conflictstyle diff3\n</code></pre> <p>Alternatively, look into using a graphical conflict-resolution tool such as kdiff3 or the Emacs built-in <code>M-x vc-resolve-coflicts</code>.</p> <p>We recommend that you set git to not push anything by default:</p> <pre><code>git config --global push.default nothing\n</code></pre> <p>This can help prevent you from accidentally pushing work to the wrong repository.</p>"},{"location":"development/git-basics/#configuring-git-on-shared-machines","title":"Configuring git on shared machines","text":"<p>If using git on shared resources, such as on the login nodes for CISL machines, then one may find their git commands being killed by sys admins due to git spawning too many threads and thus blocking (or at least slowing down) other users. To avoid this situation, you can limit the number of threads git spawns for various activities by setting the following git config variables:</p> <pre><code>git config --global --add index.threads 8\ngit config --global --add grep.threads 8\ngit config --global --add pack.threads 8\n</code></pre> <p>Please note that a limit of 8 threads was chosen specifically for CISL machines. If you are using a separate shared system you may find it beneficial to choose a different thread limit.</p>"},{"location":"development/git-basics/#git-tools-for-bash","title":"git tools for Bash","text":"<p>There are two helpful things you can do to streamline your use of git if you use the bash shell. These are completely optional, but improve your git experience. These are documented in the appendix of the excellent Pro Git book.</p>"},{"location":"development/git-basics/#updating-your-login-to-a-github-token","title":"Updating your login to a GitHub token","text":"<p>If you have been denied access to push to a GitHub repo, note that the old password system has been deprecated and no longer works. If you do not make changes, you will no longer be able to work with GitHub on personal forks and private repos.</p> <p>If you only ever git clone from public repositories like ESCOMP and ESMCI, you may ignore the rest of this wiki page.</p> <p>If you've already created and are using a GitHub token, you may ignore the rest of this wiki page.</p> <p>GitHub will soon be requiring that you use a GitHub generated token (basically a long password that they autogenerate for you).</p> <ol> <li>If you are on a Mac and do not need to use your password, but still receive an error message, you may have stored your password in the keychain. Remove a password on Macs</li> <li>Create a GitHub password token. Make sure you copy it to a safe place as they only show it to you once.</li> <li> <p>Store your credentials on every machine you use GitHub on.</p> <ul> <li> <p>On a private / secure Linux system:</p> <p><code>git config --global credential.helper store</code></p> </li> <li> <p>Note that the <code>store</code> option to git's credential helper stores your GitHub token in plain text. If you are on a public machine, you should store your GitHub token in a password manager and use the credential cache mechanism to open command-line access to your GitHub repositories:</p> <p><code>git config --global credential.helper cache --timeout &lt;seconds&gt;</code></p> <p>where <code>&lt;seconds&gt;</code> is the number of seconds git 'remembers' your token. For example, to only have to enter your token once per day:</p> <p><code>git config --global credential.helper cache --timeout 86400</code></p> </li> <li> <p>On Windows:</p> <p><code>git config --global credential.helper wincred</code>     - On Macs (make sure you select the Mac tab in the middle of the window): see this documentation</p> </li> </ul> </li> <li> <p>On each machine, do a <code>git clone</code> of your personal repo. It will ask for your username and password. The password needs to be your saved token. You should only need to do this once.</p> </li> <li>To test that your credentials are successfully cached, do a new <code>git clone</code> of your personal repo. If it clones without asking for your username/password you are done.</li> </ol>"},{"location":"development/git-basics/#working-with-clones","title":"Working with clones","text":"<p>Here are some commands for creating and working with clones:</p>"},{"location":"development/git-basics/#create-a-new-clone","title":"Create a new clone","text":"<pre><code>git clone https://github.com/&lt;GitHub userid&gt;/CAM-SIMA\ncd CAM-SIMA\n</code></pre> <p>or</p> <pre><code>git clone git@github.com:&lt;GitHub userid&gt;/CAM-SIMA\ncd CAM-SIMA\n</code></pre> <p>where <code>&lt;GitHub userid&gt;</code> is your GitHub account login ID. Some useful options to the clone command are:</p> <ul> <li><code>--origin &lt;origin name&gt;</code>: A clone knows where it came from and by default, calls that location, \"origin\". You can change that name with the <code>--origin</code> option. This can come in handy when dealing with multiple upstream repositories. Change the clone directory name: By default, the clone is created in a directory with the same name as the repository. You can change this by adding a directory name to the clone command. Use the appropriate example below:</li> </ul> <pre><code>git clone https://github.com/&lt;GitHub userid&gt;/CAM-SIMA  &lt;clone_dir_name&gt;\ncd &lt;clone_dir_name&gt;\n</code></pre> <p>or</p> <pre><code>git clone git@github.com:&lt;GitHub userid&gt;/CAM-SIMA &lt;clone_dir_name&gt;\ncd &lt;clone_dir_name&gt;\n</code></pre>"},{"location":"development/git-basics/#checking-out-a-tag-or-switching-to-a-new-tag","title":"Checking out a tag or switching to a new tag","text":"<ul> <li>To check out a tag: </li> </ul> <pre><code>git checkout &lt;tag&gt;\n</code></pre> <p>note that <code>&lt;tag&gt;</code> can also be the name of a branch or a commit hash. If you specify the name of a branch, you will check out the head of the branch. If you name a remote branch (e.g., <code>origin/branch_name</code>), you will create a detached HEAD but you can still use the code. Please note that if you plan on changing the code, first create a branch (see Working with branches</p>"},{"location":"development/git-basics/#working-with-branches","title":"Working with branches","text":"<p>When you create a clone, your clone will contain pointers all the branches that existed at the clone's origin (e.g., the repository at GitHub). While you can check out these branches, however, before attempting to make any changes, you should first create a local version branch (so git can keep track of the local commits).</p> <ul> <li>To create a new local branch that starts at a certain point:</li> </ul> <pre><code>git branch &lt;new branch name&gt; &lt;tag or branch name&gt;\n</code></pre> <p>for example</p> <pre><code>git branch new_feature cam6_2_024\n</code></pre> <ul> <li>To check out a local branch:</li> </ul> <pre><code>git checkout &lt;new branch name&gt;\n</code></pre> <ul> <li>If you are working with a repository that uses <code>git-fleximod</code> (e.g., CAM-SIMA, CESM), always run that tool after checking out a new branch or tag:</li> </ul> <pre><code>bin/git-fleximod update\n</code></pre>"},{"location":"development/git-basics/#working-with-remotes-upstream-repository-locations","title":"Working with remotes (upstream repository locations)","text":"<p>While working with clones created using the methods above will be sufficient for most if not all of your development needs, there may be times when you will want to access or compare your code with code from a different repository. git has no problem storing revisions from multiple repositories in a single clone!</p> <p>To begin, your clone probably has a single remote (also known as an upstream repository). To see the current status of which upstream repositories are configured for your clone, use the <code>git remote</code> command:</p> <pre><code>git remote\n</code></pre> <p>To see the location of the remote repositories in your current directory:</p> <pre><code>git remote -v\n</code></pre> <p>You should see something like:</p> <pre><code>origin  https://github.com/gituser/CAM-SIMA (fetch)\norigin  https://github.com/gituser/CAM-SIMA (push)\n</code></pre> <p>This tells you the \"upstream\" location from where new code is downloaded (when you run <code>git fetch origin</code>) or where code is uploaded (when you run <code>git push origin &lt;branch&gt;</code>). Note that most <code>git</code> commands are purely local, using only information in the .git directory of your clone.</p> <p>You can rename an existing remote:</p> <pre><code>git remote rename origin ESCOMP\n</code></pre> <p>You can set the remote name as part of a clone command (the default is 'origin'):</p> <pre><code>git clone -o ESCOMP https://github.com/ESCOMP/cam-sima\n</code></pre>"},{"location":"development/git-basics/#adding-remote-new-upstream-repository-locations","title":"Adding remote (new upstream repository locations)","text":"<p>To add a new upstream repository, use the <code>remote add</code> command. For example:</p> <pre><code>git remote add ESCOMP https://github.com/ESCOMP/CAM-SIMA\ngit fetch --tags ESCOMP\n</code></pre> <p>You should see messages much like a new clone when you execute the <code>git fetch</code> command. Note that you can call the new remote anything, in this example we are calling it ESCOMP.</p>"},{"location":"development/git-basics/#updating-your-branch-to-latest-development","title":"Updating your branch to latest development","text":"<p>Note that while this section explains how to update your local branch to the <code>ESCOMP/CAM-SIMA/development</code> branch, the instructions can easily be generalized for any branch from any upstream remote.</p> <p>Before starting, you should have either:</p> <ul> <li>A fresh clone of your fork with the branch you wish to update checked out (see Create a new clone and Working with branches.</li> <li>An existing clone with the branch you wish to update checked out and in a clean state (i.e., make sure you do a <code>git commit</code> and that <code>git status</code> shows no modified files).</li> </ul> <p>Add the upstream remote, if you have not already done so (see Adding remotes).</p> <p>Merge the specific remote/branch into your branch. In this example, it is ESCOMP/development</p> <pre><code>git fetch ESCOMP\ngit merge ESCOMP/development\n</code></pre>"},{"location":"development/git-basics/#comparing-differences-using-git-diff","title":"Comparing differences using git diff","text":"<p>If you have a git clone, you can view differences between commits or tags. As far as <code>git diff</code> is concerned, a commit hash is the same as a tag so in the examples below will use <code>&lt;tag&gt;</code>.</p> <ul> <li>To see the full difference between two tags (i.e., a changeset):</li> </ul> <pre><code>  git diff &lt;tag1&gt; &lt;tag2&gt;\n</code></pre> <ul> <li>To see the full difference between the current checkout (sandbox) and a tag:</li> </ul> <pre><code>  git diff &lt;tag&gt;\n</code></pre> <ul> <li>To see only the names of files that are different:</li> </ul> <pre><code>  git diff --name-only &lt;tag&gt; [ &lt;tag2&gt; ]\n</code></pre> <ul> <li>To see the difference in one or more specific files:</li> </ul> <pre><code>  git diff &lt;tag&gt; [ &lt;tag2&gt; ] -- &lt;path_to_file1&gt; &lt;path_to_file2&gt;\n</code></pre>"},{"location":"development/git-basics/#configuring-and-using-a-graphical-difference-tool","title":"Configuring and using a graphical difference tool","text":"<p>git has a command, <code>difftool</code>, that can run a graphical tool on each file that is different between two commits.</p> <ul> <li>To configure <code>opendiff</code> as the graphical difference tool:</li> </ul> <pre><code>  git config --global diff.tool opendiff\n</code></pre> <ul> <li>To see the available graphical difference tools:</li> </ul> <pre><code>  git difftool --tool-help\n</code></pre> <ul> <li>To run <code>difftool</code> on <code>&lt;file1&gt;</code> and <code>&lt;file2&gt;</code></li> </ul> <pre><code>  git difftool &lt;tag&gt; [ &lt;tag2&gt; ] -- &lt;path_to_file1&gt; &lt;path_to_file2&gt;\n</code></pre> <ul> <li>To optionally run <code>difftool</code> on all files in a changeset (answer 'y' or 'n' for each file):</li> </ul> <pre><code>  git difftool &lt;tag&gt; [ &lt;tag2&gt; ]\n</code></pre> <ul> <li>To run <code>difftool</code> on all files in a changeset (i.e., same as 'y' for every file):</li> </ul> <pre><code>  yes | git difftool &lt;tag&gt; [ &lt;tag2&gt; ]\n</code></pre>"},{"location":"development/git-basics/#using-diffmerge","title":"Using <code>diffmerge</code>","text":"<p>This section contains the complete modifications needed for using the graphical tool diffmerge for \"git difftool\" and \"git mergetool\"</p> <p>There is a tool called <code>diffmerge</code> which enables both side-by-side comparison of edited files in git as well as providing a three way-pane for editing merge conflicts. This tool is available for download at: https://sourcegear.com/diffmerge/. It has been installed on izumi and derecho by the system administrators in public areas, so you don't need to download it for those machines.</p> <p>To use the differencing tool type: <code>git difftool</code></p> <p>If after a <code>git merge</code> the git command says there are conflicts, then you may type <code>git mergetool</code> to allow you to resolve the conflicts and complete the merge. The mergetool with diffmerge properly installed will display three panes. From left to right these panes are: </p> <pre><code>Code being merged in          Merged code               Your code\n</code></pre> <p>The panes are opened in a visual editor, and any changes you make in the middle pane, may be saved by selecting the save icon at the top of the screen and then exiting the window. This will finalize the merge for that particular file.</p> <p>For a presentation which can be used as a tutorial, you may refer to: Presentation on diffmerge tool for git</p> <p>The following modifications may be copy/pasted into the user's <code>.gitconfig</code> file which resides in the home directory. Since the potential for making an editing mistake is possible, it is recommended that a copy be made of the <code>.gitconfig</code> file prior to these edits in case an error is discovered.</p> <p>If you have problems, check out the tips at the bottom of this page</p> <pre><code>[diff]\n\u00a0 \u00a0 \u00a0 \u00a0 tool = diffmerge\n\u00a0 \u00a0 \u00a0 \u00a0 algorithm = histogram\n[difftooldiffmerge]\n\u00a0 \u00a0 \u00a0 \u00a0 cmd = diffmerge \\\"$LOCAL\\\" \\\"$REMOTE\\\"\n[difftool \"diffmerge\"]\n\u00a0 \u00a0 \u00a0 \u00a0 cmd = diffmerge \\\"$LOCAL\\\" \\\"$REMOTE\\\"\n[difftool]\n\u00a0 \u00a0 \u00a0 \u00a0 prompt = false\n[push]\n\u00a0 \u00a0 \u00a0 \u00a0 default = simple\n[merge]\n\u00a0 \u00a0 \u00a0 \u00a0 tool = diffmerge\n\u00a0 \u00a0 \u00a0 \u00a0 ff = false\n[mergetool \"diffmerge\"]\n\u00a0 \u00a0 \u00a0 \u00a0 cmd = diffmerge --merge --result=$MERGED $REMOTE $BASE $LOCAL\n[mergetool]\n\u00a0 \u00a0 \u00a0 \u00a0 keepBackup = false\n</code></pre> <p>Useful tips</p> <ul> <li>On derecho, if you get an error message about diffmerge not being loaded, make sure you are using <code>ncarenv/23.09</code> or newer (to check say \"module list\")</li> <li>If you do not get a response when clicking on the \"git mergetool\" window, make sure you find the \"conflict\" popup and hit \"exit\" on it</li> <li>If your git mergetool gives blank windows and says: \"Files are identical or equivalent under the current RuleSet\", hit OK and then go to the File dropdown menu and select \"Reload\". This filled in the blank windows for the user with this error. <ul> <li>CAUTION: Check your file carefully if you do this, as a second user who did this discovered that all of the changes which were automatically merged did not reside in the final saved version.</li> </ul> </li> </ul>"},{"location":"development/git-faq/","title":"git &amp; GitHub FAQ","text":""},{"location":"development/git-faq/#q-how-can-i-clone-someones-git-clone-to-my-directory-on-the-same-machine","title":"Q: How can I clone someone's git clone to my directory on the same machine?","text":"<p>A: <code>git clone &lt;path_name&gt; [&lt;local_dir&gt;]</code> where <code>&lt;path_name&gt;</code> is the location of the source git clone and the optional <code>&lt;local_dir&gt;</code> is the name of the clone (default is a local directory of the same name as the original).</p>"},{"location":"development/git-faq/#q-how-can-i-clone-someones-git-clone-to-my-directory-on-a-different-machine","title":"Q: How can I clone someone's git clone to my directory on a different machine?","text":"<p>A: <code>git clone ssh://&lt;user&gt;@&lt;machine&gt;:&lt;path_name&gt; [&lt;local_dir&gt;]</code> where <code>&lt;user&gt;</code> is your user name on the remote machine, <code>&lt;machine&gt;</code> is the machine name (e.g., derecho.hpc.ucar.edu), <code>&lt;path_name&gt;</code> is the location of the source git clone on the remote machine, and the optional <code>&lt;local_dir&gt;</code> is the name of the clone (default is a local directory of the same name as the original).</p>"},{"location":"development/git-faq/#q-how-can-i-look-at-someones-pr-code","title":"Q: How can I look at someone's PR code?","text":"<p>A: There a a few ways to do this:</p> <ul> <li>On GitHub (like looking at any other code on GitHub)</li> <li>Add the PR fork to my remote (allows using tools such as <code>git diff</code> or <code>git difftool</code> with your existing branches or <code>development</code>)</li> <li>As a clone (standalone clone on your machine).</li> </ul> <p>A first step is to find the link to the fork's branch. Just below the PR is a line that starts with a colored oval (e.g., \"Open\" in green) and looks something like:</p> <pre><code>Octocat wants to merge 123 commits into ESCOMP:development from Octocat:amazing-new-feature\n</code></pre> <p>Clicking on the last part (<code>Octocat:amazing-new-feature</code>) will take you to the correct branch where you can browse the code (the first method above). If you want to download that code, click the green \"Code\" button and then click the clipboard icon. Be sure to take note of the branch name.</p> <ul> <li>To load this code into your clone, cd to your clone directory, add the PR fork as a new remote, and checkout the branch. For instance:</li> </ul> <pre><code>    git remote add octocat https://github.com/octocat/CAM-SIMA.git\n    git fetch --no-tags octocat\n    git checkout octocat/amazing-new-feature\n</code></pre> <p>Instead of the <code>checkout</code> you can also do diffs:</p> <pre><code>    git difftool origin/development octocat/amazing-new-feature\n</code></pre> <ul> <li>If you want to make a new clone with the PR code, simply do:</li> </ul> <pre><code>    git clone -b amazing-new-feature octocat https://github.com/octocat/CAM-SIMA.git octocat_cam\n    cd octocat_cam-sima\n</code></pre>"},{"location":"development/git-faq/#q-why-do-pull-request-pr-code-review-take-so-long","title":"Q: Why do Pull Request (PR) code review take so long?","text":"<p>A: A code review must fulfill three purposes:</p> <ul> <li>Code reviewers must make sure that new and/or changed code does not affect any currently-supported functionality (i.e., it cannot break anything).<ul> <li>While regression tests will catch many of these issues, reviewers must also check for usage of or reliance on deprecated code, and also for any code which is not supported on all platforms and compilers used by the CESM community.</li> </ul> </li> <li>Code reviewers must make sure that any new functionality or changes are implemented correctly and at least somewhat efficiently. They must also ensure that important changes are tested against future regressions.</li> <li>The CAM SE team is almost always engaged in several projects to implement new CAM functionality along with supporting infrastructure. Each CAM SE usually looks at each PR in order to prevent new code from interfering with those plans.</li> </ul> <p>The first two steps are usually completed by a single SE although SEs engaged in a final review will often find missed errors. This is similar to peer reviewers finding problems with a paper even after reviews done by colleagues.</p>"},{"location":"development/git-faq/#q-how-do-i-update-my-branch-to-the-current-cam_development","title":"Q: How do I update my branch to the current cam_development?","text":"<p>A: see this section</p>"},{"location":"development/git-fleximod/","title":"git-fleximod","text":""},{"location":"development/git-fleximod/#populate-andor-update-your-externals","title":"Populate and/or update your externals","text":"<p>Run <code>bin/git-fleximod update</code></p> <p>The process will either:</p> <ul> <li>complete and you're good to go</li> <li>indicate to you that modifications have been made in certain modules<ul> <li>this means you should either go commit those mods or remove them</li> <li>you can also (if you're sure!) run <code>bin/git-fleximod update -f</code> to force overwrite all externals</li> </ul> </li> </ul>"},{"location":"development/git-fleximod/#update-external-repo-or-tag","title":"Update external repo or tag","text":"<p>To add or update an external repo to CAM-SIMA, the following steps must be done:</p> <ol> <li>Modify the <code>.gitmodules</code> file at the head of CAM-SIMA to add or update the external.  Explanations for what each entry in the <code>.gitmodules</code> file is can be found on Github here</li> <li>Once the <code>.gitmodules</code> file has been updated, go to the head of CAM-SIMA and run <code>bin/git-fleximod update</code>.  This will bring in the new external code into your local repo (but will not commit them).</li> <li>Once you are ready to officially commit the changes, then make sure to commit both the modified <code>.gitmodules</code> file, and the updated submodule itself.  An easy way to make sure you have commited everything is to run <code>git status</code> and make sure there are no files or directories that have been modified but are still un-staged.</li> </ol> <p>Once all of that is done then congrats!  A new external has been successfully added/updated.   </p>"},{"location":"development/tool-recommendations/","title":"Tool recommendations","text":"<p>This page lists recommendations for various tools one might use during CAM-SIMA development.</p> <p>Please note that these standards are currently in development, and thus any of them could change at any time.</p>"},{"location":"development/tool-recommendations/#version-control","title":"Version Control","text":"<p>The recommended version control tool is git.</p>"},{"location":"development/tool-recommendations/#repository-hosting","title":"Repository Hosting","text":"<p>We recommend Github for hosting software repositories</p>"},{"location":"development/tool-recommendations/#cicd","title":"CI/CD","text":"<p>When possible, we recommend running any CI/CD workflows using Github Actions.</p>"},{"location":"development/tool-recommendations/#container-software","title":"Container Software","text":"<p>We recommend using Docker for building and running containers.</p> <p>More to Come!</p>"},{"location":"usage/creating-a-case/","title":"Creating, configuring, and running a case","text":"<p>Because CAM-SIMA uses the CIME build system, creating and configuration a case is mostly the same as it was in CAM7 (and in CESM). But! We're going to assume you know nothing.</p>"},{"location":"usage/creating-a-case/#1-run-create_newcase","title":"1. Run <code>create_newcase</code>","text":"<p>Before you create a case:</p> <ol> <li>Choose the correct machine to run your case on (if this is a high-resolution or long run, you will likely want to choose derecho!)</li> <li>Consult the git basics if you need a new clone</li> <li>Make sure you have run <code>bin/git-fleximod update</code> to update and/or populate your externals</li> <li>Navigate to <code>$CAM-SIMA/cime/scripts</code></li> </ol> <p>Assuming you have completed the above steps and have a nice checkout of a development branch of CAM-SIMA, let's go!</p> <p>Here is the (basic) structure of the command for create_newcase:</p> <pre><code>./create_newcase --case &lt;CASEDIR&gt; --compset &lt;COMPSET_NAME&gt; --res &lt;RESOLUTION&gt; --compiler &lt;COMPILER&gt; --project &lt;PROJECT KEY&gt; --run-unsupported\n</code></pre> <p>To break that down piece by piece:</p> <ul> <li><code>--case &lt;CASEDIR&gt;</code> (optional): The <code>case</code> argument specifies the full path to the directory you would like to be created, in which your case will reside.<ul> <li>pro tip: if you choose to put your case directory in your scratch directory, your <code>run</code> and <code>bld</code> directories will be automatically placed within the case directory<ul> <li>on derecho, this means: <code>--case /glade/derecho/scratch/&lt;username&gt;/&lt;case_name&gt;</code></li> <li>on izumi, this means:   <code>--case /scratch/cluster/&lt;username&gt;/&lt;case_name&gt;</code></li> </ul> </li> <li>if you do not specify a case directory, it will default to your <code>$CAM-SIMA/cime/scripts</code> directory (and, eventually, your <code>run</code> and <code>bld</code> directories will default to a new directory in your scratch space)</li> </ul> </li> <li><code>--compset &lt;COMPSET_NAME&gt;</code> (required): the compset (or \"component set\") tells CIME which base-level configurations you want to run with (including model versions and input data sets)<ul> <li>The compset supplied to the <code>create_newcase</code> command can be either:<ul> <li>The long name of a compset OR</li> <li>The alias (if it exists) for the compset</li> </ul> </li> <li>Compset options and aliases can be found in here (<code>$CAM-SIMA/cime_config/config_compsets.xml</code>)</li> <li>The structure of a compset long name is <code>&lt;initialization time&gt;_&lt;atmosphere model&gt;_&lt;land model&gt;_&lt;sea-ice model&gt;_&lt;ocean model&gt;_&lt;river runoff model&gt;_&lt;land ice model&gt;_&lt;wave model&gt;</code><ul> <li>Additional context: for each of the seven model components of the compset configuration, there can be three different implementations:<ul> <li>active (prognostic, full): solves a complex set of equations to describe model's behavior (must solve all equations on a numerical grid)</li> <li>data: version that sends/receives same variables to/from other models, but read from files rather than computed from equations (reduces feedback within a system)</li> <li>stub: occupies the required place in the driver but does not send or receive data</li> </ul> </li> </ul> </li> </ul> </li> <li><code>--res &lt;RESOLUTION&gt;</code> (required): the resolution specifies both the dycore being run and the grid.<ul> <li>The structure of the resolution argument is: <code>&lt;atmosphere&gt;_&lt;ocean&gt;_&lt;mask&gt;</code></li> <li>The resolution determines the dycore:<ul> <li>A grid resolution that looks like \"ne*\" indicates that this is spectral element (SE) cube sphere grid (SE dycore)</li> <li>A grid resolution that looks like \"C*\" indicates that this is the FV3 (finite volume cubed sphere) dycore [not yet implemented in CAM-SIMA]</li> <li>A grid resolution that looks like \"mpasa*\" indicates that this is an MPAS (Model for Prediction Across Scales) grid (MPAS dycore) [work-in-progress in CAM-SIMA]</li> </ul> </li> <li>You can find the options for these model grid aliases in <code>$CAM-SIMA/ccs_config/modelgrid_aliases_nuopc.xml</code></li> <li>Most often, for testing CAM-SIMA, we use a coarse SE grid like <code>ne3pg3_ne3pg3_mg37</code> or <code>ne5_ne5_mg37</code></li> </ul> </li> <li><code>--compiler &lt;COMPILER&gt;</code> (optional): the compiler you wish to use<ul> <li>Options:<ul> <li>on derecho:<ul> <li>intel (default)</li> <li>gnu</li> <li>nvhpc</li> </ul> </li> <li>on izumi:<ul> <li>intel (default) - NOTE: intel is not to be trusted on izumi (it's a known-buggy version)</li> <li>gnu</li> <li>nag - NOTE: until the nag version is updated beyond 7.0, CAM-SIMA won't work with nag</li> </ul> </li> </ul> </li> </ul> </li> <li><code>--project &lt;PROJECT KEY&gt;</code>: a project key to charge to<ul> <li>Only needed on derecho</li> <li>You can see the project keys you can use here (click on your primary group)<ul> <li>You can also see how much of the allocation has been used/is left by navigating to Reports -&gt; Project Search and searching for the key</li> </ul> </li> </ul> </li> <li><code>--run-unsupported</code>: this flag is mostly in place to indicate to scientists that the configuration they're choosing to run is not scientifically supported.</li> </ul> <p>Given all that, let's say you run the following command on izumi (assuming you're this mysterious person \"courtneyp\"):</p> <pre><code>./create_newcase --case /scratch/cluster/courtneyp/kessler-ne5-gnu-0722 --compset FKESSLER --res ne5_ne5_mg37 --compiler gnu --run-unsupported\n</code></pre> <p>What will happen is that a new case directory will be created here: <code>/scratch/cluster/courtneyp/kessler-ne5-gnu-0722</code> that will be configured to run the FKESSLER compset (long name: <code>2000_CAM%KESSLER_SLND_SICE_SOCN_SROF_ SGLC_SWAV</code>) with the SE dycore and the ne5 grid.</p>"},{"location":"usage/creating-a-case/#2-configure-the-case","title":"2. Configure the case","text":"<p>Navigate into your shiny new case directory and run <code>./case.setup</code></p> <p>From here, there are A LOT of configuration options. We'll highlight a few here that you'll use often.</p>"},{"location":"usage/creating-a-case/#xml-configurations","title":"XML configurations","text":"<p>Many configurable settings can be found within the env_*.xml files in your case directory. In order to protect again typos, it's not advised to edit those directly. Instead, you will run <code>./xmlchange</code> commands to alter those settings (and <code>./xmlquery</code> can give you the current setting). You can find additional information on the configurable xml variables here. A few to highlight:</p> <ul> <li><code>CAM_CONFIG_OPTS</code>: This is where we tell CAM-SIMA what physics scheme(s) we wish to run, as well as if we wish to run the <code>null</code> dycore.<ul> <li>FKESSLER will default to <code>--physics-suites kessler --analytic_ic</code>, which means we're running the <code>suite_kessler.xml</code> SDF with the SE dycore (with analytic initial conditions - no need to supply an ncdata initial conditions file)</li> <li>If you instead want to run a test with the null dycore, you'll want to change this with <code>./xmlchange CAM_CONFIG_OPTS = \"--physics-suites kessler --dyn none\"</code></li> </ul> </li> <li><code>CAM_LINKED_LIBS</code>: Hopefully, you won't have to change this often; however, if you are getting linking errors during your build, try turning off the linked libraries (<code>./xmlchange CAM_LINKED_LIBS=''</code>)</li> <li><code>DOUT_S</code>: This is the flag to archive log files of successful runs. During development, we advise turning this off so your log files don't disappear on you (<code>./xmlchange DOUT_S=False</code>)</li> <li><code>STOP_OPTION</code> &amp; <code>STOP_N</code>: How long you are going to run the model. If <code>STOP_N</code> is 8 and <code>STOP_OPTION</code> is \"ndays\", you are setting the model up to run for 8 days.<ul> <li>the options for <code>STOP_OPTION</code> are: 'nsteps', 'nseconds', 'nminutes', 'nhours', 'ndays', 'nmonths', 'nyears'</li> <li><code>STOP_N</code> is an integer</li> <li>NOTE: if you are running the ncdata_check with snapshot files, keep the number of timesteps you are running at or below the number of timesteps on the snapshot files</li> <li>NOTE #2: These configurations can be updated without rebuilding the case</li> </ul> </li> <li><code>DEBUG</code>: A flag to turn on debug mode for the run (runs without compiler optimizations) - this is very useful during development! It defaults to \"False\", so you can turn it on with <code>./xmlchange DEBUG=True</code></li> <li><code>RUNDIR</code>: this is the path to the <code>run</code> directory for your case. The <code>bld</code> directory will exist one level up.</li> </ul> <p>If you run <code>./xmlchange</code>, the output will tell you if you need to re-set up and/or do a clean build of your case.</p>"},{"location":"usage/creating-a-case/#namelist-configurations","title":"Namelist configurations","text":"<p>There are countless namelist configuration options. These can be modified by updating the <code>user_nl_cam</code> file in your case directory. Namelist options can be updated without rebuilding the case.</p> <ul> <li>How to configure the namelist for history/output</li> <li>Information on namelist reader generation</li> <li>You can see the full CAM6 list of namelist options here, keeping in mind that most of those options have not yet been ported to CAM-SIMA</li> </ul>"},{"location":"usage/creating-a-case/#3-build-the-case","title":"3. Build the case","text":"<p>Run <code>./case.build</code></p> <p>The console output will tell you the progress of the build. If you get to <code>MODEL BUILD HAS FINISHED SUCCESSFULLY</code>, hooray!</p> <p>Debugging tips</p>"},{"location":"usage/creating-a-case/#4-run-the-case","title":"4. Run the case","text":"<p>Run <code>./case.submit</code></p> <p>The job will be submitted to the system's queue. You can see the status of your job with the <code>qstat</code> command. Once it is finished, the log files will be in the <code>run</code> directory (unless it ran successfully AND your archiver is on)</p> <p>Debugging tips</p>"},{"location":"usage/history/","title":"History &amp; model output","text":""},{"location":"usage/history/#configuring-the-namelist","title":"Configuring the namelist","text":"<p>The syntax for updating a the configuration for a history file is:</p> <pre><code>&lt;namelist_option&gt;;&lt;volume&gt;: &lt;setting&gt;\n</code></pre> <p>Possible namelist options for your <code>user_nl_cam</code>:</p> <ul> <li><code>hist_add_avg_fields</code>: add average fields to a specified history file</li> <li><code>hist_add_inst_fields</code>: add instantaneous fields to a specified history file</li> <li><code>hist_add_min_fields</code>: add minimum fields to a specified history file</li> <li><code>hist_add_max_fields</code>: add maximum fields to a specified history file</li> <li><code>hist_remove_fields</code>: remove a given field from a specified history file</li> <li><code>hist_file_type</code>: type of file (options are \"history\", \"satellite\", and \"initial_value\") - defaults to \"history\"</li> <li><code>hist_max_frames</code>: maximum number of samples written to a specified history file (after which a new one will be created)</li> <li><code>hist_output_frequency</code>: frequency with which to write samples to a specified history file (syntax is <code>&lt;integer&gt;*&lt;multiplier&gt;</code> like <code>3*nhours</code>)</li> <li><code>hist_precision</code>: precision of the specified history file (options are \"REAL32\" and \"REAL64\") - defaults to \"REAL32\"</li> <li><code>hist_write_nstep0</code>: logical for whether or not to write the nstep = 0 sample (defaults to .false.)</li> <li><code>hist_filename_template</code>: template filename for the specified history file<ul> <li>Defaults to \"%c.cam.%u.%y-%m-%d-%s.nc\" where \"%c\" is the case name, \"%u\" is the volume, \"%y\" is the year, \"%m\" is the month, \"%d\" is the day, and \"%s\" is the number of seconds since midnight GMT, with the timestamp itself representing the model time when the file is created.</li> </ul> </li> </ul> <p>Example Take the following sample <code>user_nl_cam</code>:</p> <pre><code>hist_output_frequency;h1: 5*ndays\nhist_max_frames;h1: 3\nhist_add_inst_fields;h1: U\nhist_add_inst_fields;h1: V, Q\nhist_precision;h1: REAL64\nhist_filename_spec;h1: my-history-file%m-%d\nhist_write_nstep0;h1: .false.\n</code></pre> <p>It will be parsed by <code>hist_config.py</code> and this will be the relevant section of atm_in:</p> <pre><code>&amp;hist_config_arrays_nl\n    hist_num_inst_fields = 3\n    hist_num_avg_fields = 2\n    hist_num_min_fields = 0\n    hist_num_max_fields = 0\n    hist_num_var_fields = 0\n/\n\n&amp;hist_file_config_nl\n    hist_volume = 'h0'\n    hist_avg_fields = 'T', 'Q'\n    hist_max_frames = 1\n    hist_output_frequency = '1*month'\n    hist_precision = 'REAL32'\n    hist_file_type = 'history'\n    hist_filename_spec = '%c.cam.%u.%y-%m-%d-%s.nc'\n    hist_write_nstep0 = .false.\n/\n\n&amp;hist_file_config_nl\n    hist_volume = 'h1'\n    hist_inst_fields = 'U', \u2018V\u2019, \u2018Q\u2019\n    hist_max_frames = 3\n    hist_output_frequency = '5*ndays'\n    hist_precision = 'REAL64'\n    hist_file_type = 'history'\n    hist_filename_spec = 'my-history-file%m-%d'\n    hist_write_nstep0 = .false.\n/\n</code></pre> <p>In plain English, a one-month run with these history configuration will result in a total of three files that will look something like these:</p> <ul> <li>my-history-file01-06.nc<ul> <li>This file will contain instantaneous output for U, V, and Q (eastward_wind, northward_wind, and water vapor)</li> <li>It will contain three frames, one at each of the following times:<ul> <li>0001-01-06 (time=5)</li> <li>0001-01-11 (time=10)</li> <li>0001-01-16 (time=15)</li> </ul> </li> </ul> </li> <li>my-history-file01-21.nc<ul> <li>This file will contain instantaneous output for U, V, and Q (eastward_wind, northward_wind, and water vapor)</li> <li>It will contain three frames, one at each of the following times:<ul> <li>0001-01-21 (time=20)</li> <li>0001-01-26 (time=25)</li> <li>0001-01-31 (time=30)</li> </ul> </li> </ul> </li> <li>.cam.h0a.0001-02-01-00000.nc<ul> <li>This file will contain averaged output for T and Q (air_temperature and water vapor)</li> <li>It will have one frame with the time calculated at the midpoint of the month</li> </ul>"},{"location":"usage/history/#adding-a-diagnostic-field-to-the-cam-sima-source-code","title":"Adding a diagnostic field to the CAM-SIMA source code","text":"<p>During init time, fields can be added to the possible field list with a call to <code>history_add_field</code>:</p> <p>history_add_field(diagnostic_name, standard_name, vdim_name, avgflag, units, gridname, flag_xyfill, mixing_ratio)</p> Field Optional? Type Description diagnostic_name No string diagnostic name for the field - will be the name in netcdf output file standard_name No string CCPP standard name for the variable vdim_name No string vertical dimension: 'horiz_only' for no vertical dimension; 'lev' for vertical_layer_dimension; 'ilev' for vertical_interface_dimension avgflag No string default average flag; options: 'avg', 'lst' (instantaneous), 'min', 'max', 'var' (standard deviation) units No string variable units gridname Yes string gridname on which the variable's data is mapped (defaults to the physics grid) flag_xyfill Yes string fill value for variable values mixing_ratio Yes string constituent mixing ratio type ('wet' or 'dry'); not set to anything if not passed in <p>Example:</p> <pre><code>call history_add_field('Q', 'water_vapor_mixing_ratio_wrt_moist_air_and_condensed_water', 'lev', 'avg', 'kg kg-1', mixing_ratio='wet')\n</code></pre> <p>It's important to avoid adding calls to <code>history_add_field</code> to the CCPP-ized physics schemes (to keep them portable). Instead, create a new diagnostics scheme and place that in the <code>diagnostics</code> folder of the atmospheric_physics repository. The <code>history_add_field</code> call will be in the <code>init</code> phase.</p>"},{"location":"usage/history/#outputting-a-diagnostic-field-to-the-cam-sima-source-code","title":"Outputting a diagnostic field to the CAM-SIMA source code","text":"<p>After init time, a variable's current values can be captured for output with a call to <code>history_out_field</code>:</p> <p>history_out_field(diagnostic_name, field_values)</p> Field Optional? Type Description diagnostic_name No string diagnostic name for the field - will cause an error if the diagnostic name was not added via history_add_field field_values No real variable values to be stored in the history buffer(s) <p>Example:</p> <pre><code>call history_out_field('Q', const_array(:,:,const_idx))\n</code></pre> <p>It's important to avoid adding calls to <code>history_add_field</code> to the CCPP-ized physics schemes (to keep them portable). Instead, create a new diagnostics scheme and place that in the <code>diagnostics</code> folder of the atmospheric_physics repository. The <code>history_out_field</code> call(s) will likely be in the <code>run</code> phase.</p>"},{"location":"usage/history/#using-the-output","title":"Using the output","text":"<p>The output files can be found in your <code>run</code> directory. They are in netCDF format. </p> <p>See the ADF for lots that you can do with your results!</p> <p>A few useful commands for inspecting netCDF data:</p> <ul> <li>To output the header/metadata information for the file (includes list of variables on the file):</li> </ul> <pre><code>ncdump -h file.nc\n</code></pre> <ul> <li>To output the data for a specific variable on the file:</li> </ul> <pre><code>ncdump -v &lt;varname&gt; file.nc\n</code></pre> <ul> <li>To compare two files*:</li> </ul> <pre><code>cprnc &lt;file1_path&gt; &lt;file2_path&gt;\n</code></pre> <ul> <li>To get a slice of one file (subset of time samples):</li> </ul> <pre><code>ncks -F -d time,&lt;start time&gt;,&lt;end time&gt;,&lt;step&gt; &lt;snapshot_file&gt; &lt;output_file_name&gt;\n</code></pre> <p>Example to get time samples 3-5 from a file onto a new file called \"split-file.nc\":</p> <pre><code>ncks -F -d time,3,5,1 file.nc split-file.nc\n</code></pre> <ul> <li>To diff a variable between two files (and output the results to a new netcdf file):</li> </ul> <pre><code>ncdiff -v &lt;field_name&gt; -o &lt;output_file&gt; &lt;file1&gt; &lt;file2&gt;\n</code></pre> <p>*<code>cprnc</code> can be found:</p> <ul> <li>on derecho: <code>/glade/p/cesmdata/cseg/tools/cime/tools/cprnc/cprnc</code></li> <li>on izumi: <code>/fs/cgd/csm/tools/cime/tools/cprnc/cprnc</code></li> </ul>"}]}